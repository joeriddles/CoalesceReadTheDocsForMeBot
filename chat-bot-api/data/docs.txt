 Coalesce  Designed to help you quickly build amazing web applications, Coalesce is a rapid-development, code generation-based web application framework created by IntelliTect and built on top of: IntelliTect C#, .NET, and ASP.NET Core are the backend foundation of all Coalesce applications.Entity Framework provides the interface between your database and C# code. Coalesce will use your EF data model to generate an extensible, customizable CRUD API that will drive both your custom pages and the out-of-the-box admin pages.TypeScript enables discovery of Coalesce features through Intellisense and provides confidence that your frontend code won't break as your application grows.Vue.js provides data binding and interactivity for your application as it runs in a browser. Coalesce will generate TypeScript ViewModels to facilitate rapid development of custom pages. Vite is the development and build tooling for your frontend Vue code, enabling lightning-fast single-page application development. Coalesce integrates ASP.NET Core and Vite together, streamlining local development to require nothing more than a dotnet run or a single-click launch in your IDE. C#, .NET, and ASP.NET Core are the backend foundation of all Coalesce applications.   C#, .NET, and ASP.NET Core are the backend foundation of all Coalesce applications. Entity Framework provides the interface between your database and C# code. Coalesce will use your EF data model to generate an extensible, customizable CRUD API that will drive both your custom pages and the out-of-the-box admin pages.   Entity Framework provides the interface between your database and C# code. Coalesce will use your EF data model to generate an extensible, customizable CRUD API that will drive both your custom pages and the out-of-the-box admin pages. TypeScript enables discovery of Coalesce features through Intellisense and provides confidence that your frontend code won't break as your application grows.   TypeScript enables discovery of Coalesce features through Intellisense and provides confidence that your frontend code won't break as your application grows. Vue.js provides data binding and interactivity for your application as it runs in a browser. Coalesce will generate TypeScript ViewModels to facilitate rapid development of custom pages.    Vue.js provides data binding and interactivity for your application as it runs in a browser. Coalesce will generate TypeScript ViewModels to facilitate rapid development of custom pages.  TypeScript ViewModels Vite is the development and build tooling for your frontend Vue code, enabling lightning-fast single-page application development. Coalesce integrates ASP.NET Core and Vite together, streamlining local development to require nothing more than a dotnet run or a single-click launch in your IDE.   Vite is the development and build tooling for your frontend Vue code, enabling lightning-fast single-page application development. Coalesce integrates ASP.NET Core and Vite together, streamlining local development to require nothing more than a dotnet run or a single-click launch in your IDE. What do I do? ​ ​ You are responsible for the interesting parts of your application: Data ModelBusiness LogicExternal IntegrationsPage ContentSite DesignCustom Scripting Data Model Business Logic External Integrations Page Content Site Design Custom Scripting What is done for me? ​ ​ Coalesce builds the part of your application that are mundane and monotonous to build: Client side TypeScript ViewModels that mirror your data model for both lists and individual objects. Utilize these to rapidly build out your application's various pages.APIs to interact with your models via endpoints like List, Get, Save, and more.Out-of-the-box Vue Components for common controls like dates, selecting objects via drop downs, enums, etc. Dropdowns support searching and paging automatically.A complete set of admin pages are provided, allowing you to read, create, edit, and delete data straight away without writing any additional code. Client side TypeScript ViewModels that mirror your data model for both lists and individual objects. Utilize these to rapidly build out your application's various pages. TypeScript ViewModels APIs to interact with your models via endpoints like List, Get, Save, and more. Out-of-the-box Vue Components for common controls like dates, selecting objects via drop downs, enums, etc. Dropdowns support searching and paging automatically. Vue Components A complete set of admin pages are provided, allowing you to read, create, edit, and delete data straight away without writing any additional code. Getting Started ​ ​ To get started with Coalesce, check out Getting Started with Vue. Getting Started with Vue While Knockout.js is still supported by Coalesce, it is a deprecated option and not recommended for new projects. If you do still want to choose Knockout, click here. here Next pageGetting StartedGetting Started ​ ​ Environment Setup ​ ​ Before you begin, ensure that you have all the requisite tools installed Recent version of the .NET SDK. If you have Visual Studio, you already have this.A recent version of Node.js (an LTS version is recommended).A compatible IDE. Recommended: Visual Studio for backend (C#) developmentVS Code for frontend (Vue, TypeScript) development (with Vue - Official and TypeScript Vue Plugin)Also consider: VS Code for full stack development.JetBrains Rider Recent version of the .NET SDK. If you have Visual Studio, you already have this. .NET SDK A recent version of Node.js (an LTS version is recommended). Node.js A compatible IDE. Recommended: Visual Studio for backend (C#) developmentVS Code for frontend (Vue, TypeScript) development (with Vue - Official and TypeScript Vue Plugin)Also consider: VS Code for full stack development.JetBrains Rider Recommended: Visual Studio for backend (C#) developmentVS Code for frontend (Vue, TypeScript) development (with Vue - Official and TypeScript Vue Plugin)Also consider: VS Code for full stack development.JetBrains Rider Recommended: Visual Studio for backend (C#) developmentVS Code for frontend (Vue, TypeScript) development (with Vue - Official and TypeScript Vue Plugin) Visual Studio for backend (C#) developmentVS Code for frontend (Vue, TypeScript) development (with Vue - Official and TypeScript Vue Plugin) Visual Studio for backend (C#) development VS Code for frontend (Vue, TypeScript) development (with Vue - Official and TypeScript Vue Plugin) Vue - Official TypeScript Vue Plugin Also consider: VS Code for full stack development.JetBrains Rider VS Code for full stack development.JetBrains Rider VS Code for full stack development. JetBrains Rider Creating a Project ​ ​ The quickest and easiest way to create a new Coalesce Vue application is to use the dotnet new template. In your favorite shell:   Project Structure ​ ​ Important The Vue template is based on Vite. You are strongly encouraged to read through at least the first few pages of the Vite Documentation before getting started on any development. Vite Vite Documentation The structure of the Web project follows the conventions of both ASP.NET Core and Vite. The Vue-specific folders are as follows: /src - Files that should be compiled into your frontend application. CSS/SCSS, TypeScript, Vue SFCs, and so on./public - Static assets that should be served as files. Includes index.html, the root document of the application./wwwroot - Target for compiled output. This directory is excluded from git. /src - Files that should be compiled into your frontend application. CSS/SCSS, TypeScript, Vue SFCs, and so on. /public - Static assets that should be served as files. Includes index.html, the root document of the application. /wwwroot - Target for compiled output. This directory is excluded from git. During development, no special tooling is required to build your frontend code. Coalesce's UseViteDevelopmentServer in ASP.NET Core will take care of that automatically when the application starts. Just make sure NPM packages have been installed (npm ci). Data Modeling ​ ​ At this point, you can open up the newly-created solution in Visual Studio and run your application. However, your application won't do much without a data model, so you will probably want to do the following before running: Create an initial Data Model by adding EF entity classes to the data project and the corresponding DbSet<> properties to AppDbContext. You will notice that the starter project includes a single model, Widget, to start with. Feel free to change this model or remove it entirely. Read Entity Models for more information about creating a data model.Run dotnet ef migrations add Init (Init can be any name) in the data project to create an initial database migration.Run Coalesce's code generation by either:Running dotnet coalesce in the web project's root directoryRunning the coalesce npm script (Vue) or gulp task (Knockout) in the Task Runner Explorer Create an initial Data Model by adding EF entity classes to the data project and the corresponding DbSet<> properties to AppDbContext. You will notice that the starter project includes a single model, Widget, to start with. Feel free to change this model or remove it entirely. Read Entity Models for more information about creating a data model. Create an initial Data Model by adding EF entity classes to the data project and the corresponding DbSet<> properties to AppDbContext. You will notice that the starter project includes a single model, Widget, to start with. Feel free to change this model or remove it entirely. Read Entity Models for more information about creating a data model. Data Model Entity Models Run dotnet ef migrations add Init (Init can be any name) in the data project to create an initial database migration. Run dotnet ef migrations add Init (Init can be any name) in the data project to create an initial database migration. Run Coalesce's code generation by either:Running dotnet coalesce in the web project's root directoryRunning the coalesce npm script (Vue) or gulp task (Knockout) in the Task Runner Explorer Run Coalesce's code generation by either: Running dotnet coalesce in the web project's root directoryRunning the coalesce npm script (Vue) or gulp task (Knockout) in the Task Runner Explorer Running dotnet coalesce in the web project's root directory Running the coalesce npm script (Vue) or gulp task (Knockout) in the Task Runner Explorer You're now at a point where you can start creating your own pages! Building Pages & Features ​ ​ Lets say we've created a model called Person as follows, and we've ran code generation with dotnet coalesce: model We can create a details page for a Person by creating a Single File Component in MyApplication.Web/src/views/person-details.vue: Single File Component Note In the code above, c-display is a component that comes from the Vuetify Components for Coalesce. c-display Vuetify Components For simple property types like string and number you can always use simple template interpolation syntax, but for more complex properties like dates, c-display is handy to use because it includes features like built-in date formatting. c-display We then need to add route to this new view. In MyApplication.Web/src/router.ts, add a new item to the routes array: With these pieces in place, we now have a functioning page that will display details about a person. We can start up the application (or, if it was already running, refresh the page) and navigate to /person/1 (assuming a person with ID 1 exists - if not, navigate to /admin/Person and create one). From this point, you can start adding more fields, more features, and more flair to the page. Check out all the other documentation in the sidebar to see what else Coalesce has to offer, including the Vue Overview. Vue Overview Previous pageIntroduction Next pageEntity ModelsEntity Models ​ ​ Models are the core business objects of your application - they serve as the fundamental representation of data in your application. The design of your models is very important. In Entity Framework Core (EF), data models are just Plain Old CLR Objects (POCOs). Entity Framework Core Building a Data Model ​ ​ To start building your data model that Coalesce will generate code for, follow the best practices for EF Core. Guidance on this topic is available in abundance in the Entity Framework Core documentation. EF Core Entity Framework Core documentation Don't worry about querying or saving data when you're just getting started - Coalesce will provide a lot of that functionality for you, and it is very easy to customize what Coalesce offers later. To get started, just build your POCOs and DbContext classes. Annotate your DbContext class with [Coalesce] so that Coalesce will discover it and generate code based off of your context for you. Before you start building, you are highly encouraged to read the sections below. The linked pages explain in greater detail what Coalesce will build for you for each part of your data model. Properties ​ ​ Read Properties for an outline of the different types of properties that you may place on your models and the code that Coalesce will generate for each of them. Properties Attributes ​ ​ Coalesce provides a number of C# attributes that can be used to decorate your model classes and their properties in order to customize behavior, appearance, security, and more. Coalesce also supports a number of annotations from System.ComponentModel.DataAnnotations. Read Attributes to learn more. Attributes Methods ​ ​ You can place both static and interface methods on your model classes. Any public methods annotated with [Coalesce] will have a generated API endpoint and corresponding generated TypeScript members for calling this API endpoint. Read Methods to learn more. [Coalesce] Methods Customizing CRUD Operations ​ ​ Once you've got a solid data model in place, its time to start customizing the way that Coalesce will read your data, as well as the way that it will handle your data when processing creates, updates, and deletes. Data Sources ​ ​ The method by which you can control what data the users of your application can access through Coalesce's generated APIs is by creating custom data sources. These are classes that allow complete control over the way that data is retrieved from your database and provided to clients. Read Data Sources to learn more. Data Sources Behaviors ​ ​ Behaviors in Coalesce are to mutating data as data sources are to reading data. Defining a behaviors class for a model allows complete control over the way that Coalesce will create, update, and delete your application's data in response to requests made through its generated API. Read Behaviors to learn more. Behaviors Previous pageGetting Started Next pageExternal TypesExternal Types ​ ​ In Coalesce, any type which is connected to your data model but is not directly part of it is considered to be an "external type". The collection of external types for a data model looks like this: Take all of the api-served types in your data model. This includes Entity Models and Custom DTOs.Take all of the property types, method parameters, and method return types of these types.Any of these types which are not built-in scalar types and not one of the aforementioned api-served types are external types.For any external type discovered, any of the property types which qualify under the above rules are also external types. Take all of the api-served types in your data model. This includes Entity Models and Custom DTOs. Entity Models Custom DTOs Take all of the property types, method parameters, and method return types of these types. Any of these types which are not built-in scalar types and not one of the aforementioned api-served types are external types. For any external type discovered, any of the property types which qualify under the above rules are also external types. WARNING Be careful when using types that you do not own for properties and method returns in your data model. When Coalesce generates external type ViewModels and DTOs, it will not stop until it has exhausted all paths that can be reached by following public property types and method returns. In general, you should only expose types that you have created so that you will always have full control over them. Mark any properties you don't wish to expose with [InternalUse], or make those members non-public. [InternalUse] Generated Code ​ ​ For each external type found in your application's model, Coalesce will generate: A Generated DTOA TypeScript Model A Generated DTO Generated DTO A TypeScript Model TypeScript Model Example Data Model ​ ​ For example, in the following scenario, the following classes are considered as external types: PluginMetadata, exposed through a getter-only property on ApplicationPlugin.PluginResult, exposed through a method return on ApplicationPlugin. PluginMetadata, exposed through a getter-only property on ApplicationPlugin. PluginResult, exposed through a method return on ApplicationPlugin. PluginHandler is not because it not exposed by the model, neither directly nor through any of the other external types. Loading & Serialization ​ ​ External types have slightly different behavior when undergoing serialization to be sent to the client. Unlike database-mapped types which are subject to the rules of Include Tree, external types ignore the Include Tree when being mapped to DTOs for serialization. Read External Type Caveats for a more detailed explanation of this exception. Include Tree External Type Caveats Previous pageEntity Models Next pageServicesServices ​ ​ In a Coalesce application, you are likely to end up with a need for some API endpoints that aren't closely tied with your regular data model. While you could stick Static Methods on one of your entities, do so is detrimental to the organization of your code. Static Methods Instead, Coalesce allows you to generate API Controllers and a TypeScript client from a service. A service, in this case, is nothing more than a C# class or an interface with methods on it, annotated with [Coalesce, Service]. An implementation of this class or interface must be injectable from your application's service container, so a registration in Startup.cs is needed. The instance methods of these services work just like other custom Methods in Coalesce, with one notable distinction: Instance methods don't operate on an instance of a model, but instead on a dependency injected instance of the service. Methods Generated Code ​ ​ For each external type found in your application's model, Coalesce will generate: An API controller with endpoints that correspond to the service's instance methods.A TypeScript client containing the members outlined in Methods for invoking these endpoints. An API controller with endpoints that correspond to the service's instance methods. A TypeScript client containing the members outlined in Methods for invoking these endpoints. Methods Example Service ​ ​ An example of a service might look something like this: With an implementation: And a registration: While it isn't required that an interface for your service exist (you can generate directly from the implementation), it is highly recommended that an interface be used. Interfaces increase testability and reduce risk of accidentally changing the signature of a published API, among other benefits. Previous pageExternal Types Next pageCustom DTOsCustom DTOs ​ ​ In addition to the generated Generated C# DTOs that Coalesce will create for you, you may also create your own implementations of an IClassDto. These types are first-class citizens in Coalesce - you will get a full suite of features surrounding them as if they were entities. This includes generated API Controllers, Admin Views, and full TypeScript ViewModels and TypeScript List ViewModels. Generated C# DTOs TypeScript ViewModels TypeScript List ViewModels The difference between a Custom DTO and the underlying entity that they represent is as follows: The only time your custom DTO will be served is when it is requested directly from one of the endpoints on its generated controller, or when its type is explicitly used by a method or property of another type.When mapping data from your database, or mapping data incoming from the client, the DTO itself must manually map all properties, since there is no corresponding Generated DTO. Attributes like [DtoIncludes] & [DtoExcludes] and property-level security through Security Attributes have no effect on custom DTOs, since those attribute only affect what get generated for Generated C# DTOs. The only time your custom DTO will be served is when it is requested directly from one of the endpoints on its generated controller, or when its type is explicitly used by a method or property of another type. The only time your custom DTO will be served is when it is requested directly from one of the endpoints on its generated controller, or when its type is explicitly used by a method or property of another type. method property When mapping data from your database, or mapping data incoming from the client, the DTO itself must manually map all properties, since there is no corresponding Generated DTO. Attributes like [DtoIncludes] & [DtoExcludes] and property-level security through Security Attributes have no effect on custom DTOs, since those attribute only affect what get generated for Generated C# DTOs. When mapping data from your database, or mapping data incoming from the client, the DTO itself must manually map all properties, since there is no corresponding Generated DTO. Attributes like [DtoIncludes] & [DtoExcludes] and property-level security through Security Attributes have no effect on custom DTOs, since those attribute only affect what get generated for Generated C# DTOs. Generated DTO [DtoIncludes] & [DtoExcludes] Security Attributes Generated C# DTOs Creating a Custom DTO ​ ​ To create a custom DTO, define a class annotated with [Coalesce] that implements IClassDTO<T>, where T is an EF Core POCO with a corresponding DbSet<T> on a DbContext that has also been exposed with [Coalesce]. Add any Properties to it just as you would add model properties to a regular EF model. If you are not exposing a DbContext class with [Coalesce] but still wish to create a Custom DTO based upon one of its entities, you can inherit from IClassDTO<T, TContext> instead as a means of explicitly declaring the type of the DbContext. [Coalesce] [Coalesce] Properties model properties [Coalesce] Next, ensure that one property is annotated with [Key] so that Coalesce can know the primary key of your DTO in order to perform database lookups and keep track of your object uniquely in the client-side TypeScript. Now, populate the required MapTo and MapFrom methods with code for mapping from and to your DTO, respectively (the methods are named with respect to the underlying entity, not the DTO). Most properties probably map one-to-one in both directions, but you probably created a DTO because you wanted some sort of custom mapping - say, mapping a collection on your entity with a comma-delimited string on the DTO. This is also the place to perform any user-based, role-based, property-level security. You can access the current user on the IMappingContext object. WARNING Custom DTOs do not utilize property-level Security Attributes nor [DtoIncludes] & [DtoExcludes], since these are handled in the Generated DTOs. If you need property-level security or trimming, you must write it yourself in the MapTo and MapFrom methods. Security Attributes [DtoIncludes] & [DtoExcludes] Generated DTOs If you have any child objects on your DTO, you can invoke the mapper for some other object using the static Mapper class. Also seen in this example is how to respect the Include Tree when mapping entity types; however, respecting the IncludeTree is optional. Since this DTO is a custom type that you've written, if you're certain your use cases don't need to worry about object graph trimming, then you can ignore the IncludeTree. If you do ignore the IncludeTree, you should pass null to calls to Mapper - don't pass in the incoming IncludeTree, as this could cause unexpected results. Include Tree Using Custom DataSources and Behaviors ​ ​ Declaring an IClassDto DataSource ​ ​ When you create a custom DTO, it will use the Standard Data Source and Standard Behaviors just like any of your regular Entity Models. If you wish to override this, your custom data source and/or behaviors MUST be declared in one of the following ways: Standard Data Source Standard Behaviors Entity Models As a nested class of the DTO. The relationship between your data source or behaviors and your DTO will be picked up automatically.c#[Coalesce]
public class CaseDto : IClassDto<Case>
{
    [Key]
    public int CaseId { get; set; }

    public string Title { get; set; }
    
    ...

    public class MyCaseDtoSource : StandardDataSource<Case, AppDbContext>
    {
        ...
    }
}With a [DeclaredFor] attribute that references the DTO type:c#[Coalesce]
public class CaseDto : IClassDto<Case>
{
    [Key]
    public int CaseId { get; set; }

    public string Title { get; set; }
    
    ...
}

[Coalesce, DeclaredFor(typeof(CaseDto))]
public class MyCaseDtoSource : StandardDataSource<Case, AppDbContext>
{
    ...
} As a nested class of the DTO. The relationship between your data source or behaviors and your DTO will be picked up automatically.c#[Coalesce]
public class CaseDto : IClassDto<Case>
{
    [Key]
    public int CaseId { get; set; }

    public string Title { get; set; }
    
    ...

    public class MyCaseDtoSource : StandardDataSource<Case, AppDbContext>
    {
        ...
    }
} As a nested class of the DTO. The relationship between your data source or behaviors and your DTO will be picked up automatically. With a [DeclaredFor] attribute that references the DTO type:c#[Coalesce]
public class CaseDto : IClassDto<Case>
{
    [Key]
    public int CaseId { get; set; }

    public string Title { get; set; }
    
    ...
}

[Coalesce, DeclaredFor(typeof(CaseDto))]
public class MyCaseDtoSource : StandardDataSource<Case, AppDbContext>
{
    ...
} With a [DeclaredFor] attribute that references the DTO type: ProjectedDtoDataSource ​ ​ In addition to creating a Data Source by deriving from Standard Data Source, there also exists a class ProjectedDtoDataSource that can be used to easily perform projection from EF model types to your custom DTO types using EF query projections. ProjectedDtoDataSource inherits from Standard Data Source. Data Source Standard Data Source Standard Data Source Surgical Saves ​ ​ The Vue ViewModels support surgical saves through their $saveMode property, and Knockout ViewModels through the saveIncludedFields configuration. Vue ViewModels Knockout ViewModels saveIncludedFields configuration Surgical saves require DTOs on the server that are capable of determining which of their properties have been set by the model binder, as surgical saves are sent from the client by entirely omitting properties from the x-www-form-urlencoded body that is sent to the server. The Generated C# DTOs implement the necessary logic for this; however, any Custom DTOs must have this logic manually written by you, the developer. Either implement the same pattern that can be seen in the Generated C# DTOs, or do not use surgical saves with Custom DTOs. Generated C# DTOs Custom DTOs Generated C# DTOs Previous pageServices Next pageStandalone EntitiesStandalone Entities ​ ​ In Coalesce, Standalone Entities are types that behave like entity types (they can support the full suite generated CRUD endpoints), but are not based on Entity Framework. These types are discovered by Coalesce by annotating them with [Coalesce, StandaloneEntity]. entity types For these types, you must define at least one custom Data Source, and optionally a Behaviors class as well. If no behaviors are defined, the type is implicitly read-only, equivalent to turning off create/edit/delete via the Security Attributes. Data Source Behaviors Security Attributes To define data sources and behaviors for Standalone Entities, it is recommended you inherit from StandardDataSource<T> and StandardBehaviors<T>, respectively. For example: The above example is admittedly contrived, as it is unlikely that you would be using an in-memory collection as a data persistence mechanism. A more likely real-world scenario would be to inject an interface to some other data store. Data Source and Behavior classes are instantiated using your application's service provider, so any registered service can be injected. Previous pageCustom DTOs Next pageSecuritySecurity ​ ​ This page is a comprehensive overview of all the techniques that can be used in a Coalesce application to restrict the capabilities of API endpoints that Coalesce generates. The following table is a quick reference of scenarios you might encounter and how you might handle them. If you're unfamiliar with these techniques, though, then you are encouraged to read through this page to get a deeper understanding of what's available before selecting a solution. FeatureRestrictionTechniqueEntity Reads: /get,  /list,  /countDisable[Read(DenyAll)]Roles[Read("RoleName")]Prevent auto-includeOmit base call in Data Source GetQuery override.[Read(NoAutoInclude = true)] on properties or types.Any custom code:Query PredicatesFiltered IncludesConditional IncludesSort/search/filter overridesCustom Default Data SourceEntity Mutations: /save,  /bulkSave,  /deleteDisable[Create(DenyAll)] [Edit(DenyAll)] [Delete(DenyAll)]Roles[Create("Role")] [Edit("Role")] [Delete("Role")]Restrict target records (edit/delete)Custom Default Data SourceStatic ValidationValidation attributesAny custom code:SecurityValidationCustom BehaviorsMethods and ServicesDisableN/A - explicit opt-in required via [Coalesce]Roles[Execute("RoleName")]Static ValidationValidation attributesRestrict Targets (only instance methods)custom Default Data Sourcespecify data source: [LoadFromDataSource]OtherWrite custom logic in the method.Properties (All input and output for Entity CRUD, Methods, and Services) Globally Exclude[InternalUse]internal access modifier Roles Property Security AttributesRead-onlyinternal setter or no setter[Read] attribute without [Edit]other techniquesInit-only (write-once)init setterCustom securityNavigation Properties: Data SourcesScalar/Other Properties: Property Restrictions FeatureRestrictionTechnique Entity Reads: /get,  /list,  /countDisable[Read(DenyAll)] Entity Reads: /get,  /list,  /count Entity Reads: /get,  /list,  /count Entity Disable [Read(DenyAll)] [Read(DenyAll)] [Read(DenyAll)] Roles[Read("RoleName")] Roles [Read("RoleName")] [Read("RoleName")] [Read("RoleName")] Prevent auto-includeOmit base call in Data Source GetQuery override.[Read(NoAutoInclude = true)] on properties or types. Prevent auto-include Prevent auto-include auto-include Omit base call in Data Source GetQuery override.[Read(NoAutoInclude = true)] on properties or types. Omit base call in Data Source GetQuery override.[Read(NoAutoInclude = true)] on properties or types. Omit base call in Data Source GetQuery override. [Read(NoAutoInclude = true)] on properties or types. Any custom code:Query PredicatesFiltered IncludesConditional IncludesSort/search/filter overridesCustom Default Data Source Any custom code:Query PredicatesFiltered IncludesConditional IncludesSort/search/filter overrides Any custom code: Query PredicatesFiltered IncludesConditional IncludesSort/search/filter overrides Query Predicates Filtered Includes Conditional Includes Sort/search/filter overrides Custom Default Data Source Custom Default Data Source Custom Default Data Source  Entity Mutations: /save,  /bulkSave,  /deleteDisable[Create(DenyAll)] [Edit(DenyAll)] [Delete(DenyAll)] Entity Mutations: /save,  /bulkSave,  /delete Entity Mutations: /save,  /bulkSave,  /delete Entity Disable [Create(DenyAll)] [Edit(DenyAll)] [Delete(DenyAll)] [Create(DenyAll)] [Edit(DenyAll)] [Delete(DenyAll)] [Create(DenyAll)] [Edit(DenyAll)] [Delete(DenyAll)] Roles[Create("Role")] [Edit("Role")] [Delete("Role")] Roles [Create("Role")] [Edit("Role")] [Delete("Role")] [Create("Role")] [Edit("Role")] [Delete("Role")] [Create("Role")] [Edit("Role")] [Delete("Role")] Restrict target records (edit/delete)Custom Default Data Source Restrict target records (edit/delete) Custom Default Data Source Custom Default Data Source Custom Default Data Source Static ValidationValidation attributes Static Validation Validation attributes Validation attributes Validation attributes Any custom code:SecurityValidationCustom Behaviors Any custom code:SecurityValidation Any custom code: SecurityValidation Security Validation Custom Behaviors Custom Behaviors Custom Behaviors Methods and ServicesDisableN/A - explicit opt-in required via [Coalesce] Methods and Services Methods and Services Methods Services Disable N/A - explicit opt-in required via [Coalesce] N/A - explicit opt-in required via [Coalesce] Roles[Execute("RoleName")] Roles [Execute("RoleName")] [Execute("RoleName")] [Execute("RoleName")] Static ValidationValidation attributes Static Validation Validation attributes Validation attributes Validation attributes Restrict Targets (only instance methods)custom Default Data Sourcespecify data source: [LoadFromDataSource] Restrict Targets (only instance methods) Restrict Targets (only instance methods) instance methods custom Default Data Sourcespecify data source: [LoadFromDataSource] custom Default Data Sourcespecify data source: [LoadFromDataSource] custom Default Data Source custom Default Data Source specify data source: [LoadFromDataSource] [LoadFromDataSource] OtherWrite custom logic in the method. Other Write custom logic in the method. Write custom logic in the method. Properties (All input and output for Entity CRUD, Methods, and Services) Globally Exclude[InternalUse]internal access modifier Properties (All input and output for Entity CRUD, Methods, and Services)  Properties (All input and output for Entity CRUD, Methods, and Services)  Properties Globally Exclude [InternalUse]internal access modifier [InternalUse]internal access modifier [InternalUse] [InternalUse] internal access modifier  Roles Property Security Attributes  Roles  Property Security Attributes Property Security Attributes Property Security Attributes Read-onlyinternal setter or no setter[Read] attribute without [Edit]other techniques Read-only Read-only internal setter or no setter[Read] attribute without [Edit]other techniques internal setter or no setter[Read] attribute without [Edit]other techniques internal setter or no setter [Read] attribute without [Edit] other techniques other techniques Init-only (write-once)init setter Init-only (write-once) Init-only (write-once) init setter init setter init setter Custom securityNavigation Properties: Data SourcesScalar/Other Properties: Property Restrictions Custom security Custom security Navigation Properties: Data SourcesScalar/Other Properties: Property Restrictions Navigation Properties: Data SourcesScalar/Other Properties: Property Restrictions Navigation Properties: Data Sources Data Sources Scalar/Other Properties: Property Restrictions Property Restrictions Endpoint Security ​ ​ Coalesce generates API endpoints by traversing your data model's classes, starting from types annotated with [Coalesce]. This usually includes your DbContext class, as well as any Service classes or interfaces. Service Classes can be hidden from Coalesce entirely by annotating them with [InternalUse], preventing generation of API endpoints for that class, as well as preventing properties of that type from being exposed. DbSet<> properties on your DbContext class can also be annotated with [InternalUse], causing that type to be treated by Coalesce like an External Type rather than an Entity, once again preventing generation of API endpoints but without preventing properties of that type from being exposed. External Type Entity Class Security Attributes ​ ​ For each of your Entities and Custom DTOs, Coalesce generates a set of CRUD API endpoints (/get, /list, /count, /save, /bulkSave, and /delete). Entities Custom DTOs The default behavior is that all endpoints require an authenticated user (anonymous users are rejected). These endpoints can be secured by placing any or all of the [Read], [Create], [Edit], and [Delete] attributes on the the class. Each attribute can specify required roles for that action, or open that action to anonymous, unauthenticated users, or disable the endpoint entirely. [Read], [Create], [Edit], and [Delete] attributes This security is applied to the generated controllers. The [Read] attribute on a class does not affect instances of that class when those instances are present as child properties of other types, since in those scenarios the data will be coming from a different endpoint on a different controller. controllers EndpointsGoverning Attributes/get, /list, /countc#[ReadAttribute]/savec#[CreateAttribute] // Affects saves of new entities
[EditAttribute]   // Affects saves of existing entities/deletec#[DeleteAttribute]/bulkSavec#// Read permission required for the root entity:
[ReadAttribute]

// Control of each entity affected by the bulk save:
[CreateAttribute]
[EditAttribute]
[DeleteAttribute] EndpointsGoverning Attributes /get, /list, /countc#[ReadAttribute] /get, /list, /count /get, /list, /count c#[ReadAttribute] /savec#[CreateAttribute] // Affects saves of new entities
[EditAttribute]   // Affects saves of existing entities /save /save c#[CreateAttribute] // Affects saves of new entities
[EditAttribute]   // Affects saves of existing entities /deletec#[DeleteAttribute] /delete /delete c#[DeleteAttribute] /bulkSavec#// Read permission required for the root entity:
[ReadAttribute]

// Control of each entity affected by the bulk save:
[CreateAttribute]
[EditAttribute]
[DeleteAttribute] /bulkSave /bulkSave c#// Read permission required for the root entity:
[ReadAttribute]

// Control of each entity affected by the bulk save:
[CreateAttribute]
[EditAttribute]
[DeleteAttribute] Here are some examples of applying security attributes to an entity class. If a particular action doesn't need to be restricted, you can omit that attribute, but this example shows usages of all four: Method Security Attributes ​ ​ To secure the endpoints generated for your Custom Methods and Services, the [Execute] attribute can be used to specify a set of required roles for that endpoint, or to open that endpoint to anonymous users. Custom Methods Services [Execute] attribute The default behavior is that all endpoints require an authenticated user (anonymous users are rejected). For example: Property/Column Security ​ ​ Security applied via attributes to properties in Coalesce affects all usages of that property across all Coalesce-generated APIs. This includes usages of that property on types that occur as children of other types, which is a spot where class-level or endpoint-level security generally does not apply. These attributes can be placed on the properties on your Entities and External Types to apply role-based restrictions to that property. These attributes Entities External Types ReadAttribute limits the roles that can read values from that property in responses from the server.EditAttribute limits the roles that can write values to that property in requests made to the server.RestrictAttribute registers an implementation of IPropertyRestriction that allows for writing custom code to implement these restrictions. ReadAttribute limits the roles that can read values from that property in responses from the server. EditAttribute limits the roles that can write values to that property in requests made to the server. RestrictAttribute registers an implementation of IPropertyRestriction that allows for writing custom code to implement these restrictions. IPropertyRestriction This security is executed and enforced by the mapping that occurs in the generated DTOs, meaning it affects both entity CRUD APIs as well as Custom Methods. It is also checked by the Standard Data Source to prevent sorting, searching, and filtering by properties that a user is not permitted to read. generated DTOs Custom Methods Standard Data Source Internal Properties ​ ​ Properties can be hidden from Coalesce entirely, either with the [InternalUse] attribute or non-public C# access modifiers. [InternalUse] The properties in the following example are hidden entirely from all Coalesce functionality and generated APIs: Read-Only Properties ​ ​ A property in Coalesce can be made read-only in any of the following ways: Role Restrictions ​ ​ Reading and writing a property in Coalesce can be restricted by roles: A few of the examples above point out that when a property is restricted for reading by roles, those roles are also required when editing that property. This is because it usually doesn't make sense for a user to change a value when they have no way of knowing what the original value was. If you have a situation where a property should be editable without knowing the original value, use a custom method on the model to accept and set the new value. Custom Restrictions ​ ​ In addition to role-based property restrictions, you can also define property restrictions that can execute custom code for each model instance if your logic require more nuanced decisions than can be made with roles. role-based Restriction classes support dependency injection, so you can inject any supplemental services needed to make a determination. The UserCanRead method controls whether values of the restricted property will be mapped from model instances to the generated DTO. Similarly, UserCanWrite controls whether the property can be mapped back to the model instance from the generated DTO. The UserCanFilter method has a default implementation that returns false, but can be implemented if there is an appropriate, instance-agnostic way to determine if a user can sort, search, or filter values of that property. Multiple different restrictions can be placed on a single property; all of them must succeed for the operation to be permitted. Restrictions also stack on top of role attribute restrictions ([Read] and [Edit]). Row-level Security ​ ​ Data Sources ​ ​ In Coalesce, Data Sources are the mechanism that you can extend to implement row-level security on your Entities and Custom DTOs. Data Sources Entities Custom DTOs Data Sources are used when fetching results for /get, /list, and /count endpoints, and when fetching the target or result of a /save, /bulkSave, or /delete, and when fetching the invocation target of an Instance Method. Instance Method By default, your entities will be fetched using the Standard Data Source, but you can declare a custom default data source for each of your entities to override this default functionality. The default functionality here includes the default loading behavior, a feature where the Standard Data Source automatically includes the immediate relationships of requested entities. This can be suppressed by overriding the GetQuery method on your custom data source and not calling the base method, or by placing [Read(NoAutoInclude = true)] on classes or navigation properties that you do not want automatically included. Standard Data Source default loading behavior For most use cases, all your security rules will be implemented in the GetQuery/GetQueryAsync method. This is the most foundational method of the data source that all other functions in the data source build upon. Any predicates applied to the query of a type's default data source will affect all of the type's generated API endpoints (except for static custom methods). GetQuery/GetQueryAsync There are a few different techniques that you can use to apply filtering in a data source, each one working for a specific use case. The example below includes an example of each technique. Query Predicates ​ ​ The Query Predicates technique involves applying a .Where() predicate to your query to filter the root entities that are returned by the query using some database-executed logic. This is a form of row-level security and can be used to only include a record based on the values of that record in the database. Conditional Includes ​ ​ The Conditional Includes technique involves conditionally appending .Include() calls to your query only when some server-executed criteria is met. Usually this involves checking the roles of a user and only including a navigation property if the user is in the requisite role. This technique cannot be used with database-executed logic and is therefore behaves more like table-level security than row-level security. Filtered Includes ​ ​ The Filtered Includes technique involves using EF Core filtered includes to apply database-executed logic to filter the rows of child collection navigation properties. EF Core filtered includes EF filtered Includes cannot be used to apply database-executed filters to reference navigation properties due to lack of EF support - see the sections below on transform results and global query filters for two possible solutions. lack of EF support transform results global query filters A complex example using all three of the above techniques: Transform Results ​ ​ There exists a fourth technique in Data Sources for applying filtered includes: the TransformResultsAsync method. Unlike the other techniques above that are performed in the GetQuery method and applied at the beginning of the data source query pipeline, TransformResults is applied at the very end of the process against the materialized results. It also only affects the responses from the generated /get, /list, /save, /bulkSave, and /delete endpoints - it has no bearing on the invocation target of instance methods. TransformResultsAsync instance methods The primary purpose of TransformResults is to conditionally load navigation properties. This was very useful before EF Core introduced native filtered includes for collection navigation properties, and is still useful for applying filtered includes to reference navigation properties since EF does not support this. It can also be used for any kind of filtered includes if native EF filtered includes get translated into poorly-performant SQL, or it can be used to populate external type or other non-database-mapped properties on your entities. filtered includes does not support this external type The general technique for using TransformResults involves using EF Core Explicit Loading to attach additional navigation properties to the result set, and then using Coalesce's .IncludedSeparately() method in the data source's GetQuery so that Coalesce can still build the correct Include Tree to shape the serialization of your results. EF Core Explicit Loading Include Tree Alternatively, and indeed preferably, you can often formulate a query that does not use iteration and requires only a single database round-trip: Behaviors ​ ​ In Coalesce, Behaviors are the extension point to implement row-level security or other customizations of create/edit/delete operations on your Entities and Custom DTOs. Behaviors are implemented on top of data sources, meaning the client request will be rejected if the requested entity for modification cannot be loaded from the entity's default data source. Behaviors Entities Custom DTOs By default, each entity will use the Standard Behaviors, but you can declare a custom behaviors class for each of your entities to override this default functionality. Standard Behaviors custom behaviors class For most use cases, all your security rules will be implemented in the BeforeSave/BeforeSaveAsync and BeforeDelete/BeforeDeleteAsync methods. BeforeSave/BeforeSaveAsync BeforeDelete/BeforeDeleteAsync For a more complete explanation of everything you can do with behaviors, see the full Behaviors documentation page. Behaviors EF Global Query Filters ​ ​ Since Coalesce's data access layer is built on top of Entity Framework, you can also use Entity Framework's Global Query Filters feature to apply row-level security. Entity Framework's Global Query Filters This approach is less flexible than custom Coalesce data sources and has other drawbacks as well, but on the other hand it has more absolute authority, is less susceptible to issues like inadvertently returning data through unfiltered navigation properties, and can sometimes require less work to implement than individual data sources. drawbacks Global Query Filters are also the only way to implement database-executed filtered includes of reference navigation properties, as there is no version of .Include() for reference navigation properties that allows a database-executed predicate to be applied. See this open issue on EF Core. filtered includes reference navigation properties this open issue Foreign Key Injection Vulnerabilities ​ ​ When a user is saving a model with Coalesce, they can provide values for the model's foreign key properties. When this interaction takes place through a user interface, the user is not likely to produce a foreign key referencing an object that the user is not allowed to view. A malicious user, however, is a different story. Imagine a user who is brute-forcing the /save endpoint on one of your entities, enumerating values of a foreign key. The may be trying to leak data through navigation property values returned by the response from the save, or they may be trying to inject their data into an object graph that they do not otherwise have access to. If this scenario sounds like a plausible threat vector your application, be sure to perform sufficient validation of incoming foreign keys to ensure that the user is allowed to use a particular foreign key value before saving it to your database. validation Also consider making any required foreign keys that should not change for the lifetime of an entity into init-only properties (i.e. use the init accessor in C# instead of the set accessor). While this does not entirely solve the foreign key injection issue, it eliminates the need to validate that a user is not changing the parent of an object if such an operation is not desirable. Server-side Data Validation ​ ​ Coalesce, as of version 4, will by default perform server-side validation of incoming data using validation attributes. Your database will also enforce any constraints (referential integrity, not null, check constraints, etc.), but errors produced by your database will manifest as exceptions, which are not user-friendly. For any custom validation that cannot be implemented by attributes, you must implement that yourself for saves and deletes or custom methods. saves and deletes custom methods Attribute Validation ​ ​ Historically, Coalesce did not provide any automatic, attribute-based validation of incoming data. As of Coalesce 4.0, automatic server side validation using ValidationAttribute-derived attributes on your models is enabled by default. ValidationAttribute In addition to any validation attributes present on your model properties and method parameters, there are some other rules that work similarly to the default validation in ASP.NET Core: The C# 11 required keyword also acts like a RequiredAttributeIf C# nullable reference types are enabled, non-nullable reference types are required required.Non-nullable value types are implicitly optional, with the exception of non-nullable foreign keys, which are required. The C# 11 required keyword also acts like a RequiredAttribute If C# nullable reference types are enabled, non-nullable reference types are required required. Non-nullable value types are implicitly optional, with the exception of non-nullable foreign keys, which are required. To disable this functionality for your entire application, disable the corresponding configuration options on CoalesceOptions. For example, in Startup.cs or Program.cs: Each option also has a more granular override: Enabling ValidateAttributesForSaves causes the Standard Behaviors to perform validation of validation attributes during /save or /bulkSave calls, preventing a save when validation fails. This can be overridden per type or even per request by setting the ValidateAttributesForSaves property on a custom Behaviors instance. Standard Behaviors custom Behaviors Enabling ValidateAttributesForMethods causes the generated controllers for custom methods to perform validation of incoming parameters. Validation attributes may be placed on method parameters, and validation will also be performed against the members of any complex type parameters. This can be overridden per method by setting the ValidateAttributes property on ExecuteAttribute for the method. ValidateAttributesForMethods custom methods ExecuteAttribute Saves and Deletes ​ ​ Validation of /save, /bulkSave, and /delete actions against Entities and Custom DTOs are performed by the Behaviors for the type. Automatic attribute based validation can be used (saves only), or Behaviors can be overridden to perform validation and other customization of the save and delete process, as in the following example: Entities Custom DTOs Behaviors attribute based validation Custom Methods and Services ​ ​ For Custom Methods and Services, you can perform your own custom validation and return errors when validation fails. You can also use attribute based validation. Custom methods that need to return errors to the client are recommended to wrap their return type in an ItemResult<T>, allowing errors to be received and handled elegantly by your Coalesce Typescript code. Custom Methods Services attribute based validation Security Overview Page ​ ​ Coalesce provides batteries-included page that you can view to review the effective security rules in place for all the Coalesce-generated code in your project. Add this page to your application by mapping it as a route, either directly on WebHost in .NET 6+, or in UseEndpoints for 3.1+. TIP If you include the security overview in your production app, you should secure it with an authorization policy like in the example below. Alternatively, only map the endpoint in non-production environments. Example of the contents of the security overview page:  Testing Your Security ​ ​ If your application has complex security requirements and/or sensitive data that needs to be protected, you are encouraged to invest time into creating a set of automated tests to ensure that it is working how you expect. The most comprehensive way to do this is to build a suite of integration tests using Microsoft's in-memory test server infrastructure. Follow Microsoft's documentation to set up a test project, and then write tests against your API endpoints. You will want to substitute your Entity Framework database provider with an in-memory Sqlite instance, and add a mock authentication handler to simulate authentication (we're mainly focused on testing authorization, not authentication). Microsoft's in-memory test server infrastructure substitute your Entity Framework database provider mock authentication handler Previous pageStandalone Entities Next pagePropertiesProperties ​ ​ Models in a Coalesce application are just EF Core POCOs. The properties defined on your models should fit within the constraints of EF Core. Coalesce currently has a few more restrictions than what EF Core allows, but hopefully over time some of these restrictions can be relaxed as Coalesce grows in capability. Property Varieties ​ ​ The following kinds of properties may be declared on your models. Primary Key ​ ​ To work with Coalesce, your model must have a single property for a primary key. By convention, this property should be named the same as your model class with Id appended to that name, but you can also annotate a property with [Key] or name it exactly "Id" to denote it as the primary key. Foreign Keys & Reference Navigation Properties ​ ​ While a foreign key may be declared on your model using only the EF OnModuleBuilding method to specify its purpose, Coalesce won't know what the property is a key for. Therefore, foreign key properties should always be accompanied by a reference navigation property, and vice versa. In cases where the foreign key is not named after the navigation property with "Id" appended, the [ForeignKeyAttribute] may be used on either the key or the navigation property to denote the other property of the pair, in accordance with the recommendations set forth by EF Core's Modeling Guidelines. EF Core's Modeling Guidelines Collection Navigation Properties ​ ​ Collection navigation properties can be used in a straightforward manner. In the event where the inverse property on the other side of the relationship cannot be determined, [InversePropertyAttribute] will need to be used. EF Core provides documentation on how to use this attribute. Errors will be displayed at generation time if an inverse property cannot be determined without the attribute. We recommend recommended that you declare the type of collection navigation properties as ICollection<T>. EF Core provides documentation Non-mapped POCOs ​ ​ Properties of a type that are not on your DbContext will also have corresponding properties generated on the TypeScript ViewModels typed as TypeScript External ViewModels, and the values of such properties will be sent with the object to the client when requested. Properties of this type will also be sent back to the server by the client when they are encountered (currently supported by the Vue Stack only). TypeScript ViewModels TypeScript External ViewModels Vue Stack See External Types for more information. External Types Primitives, Scalars, & Dates ​ ​ Most common built-in primitive and scalar data types (numerics, strings, booleans, enums, DateTime, DateTimeOffset), and their nullable variants, are all supported as model properties. Getter-only Properties ​ ​ Any property that only has a getter will also have a corresponding property generated in the TypeScript ViewModels, but won't be sent back to the server during any save actions. TypeScript ViewModels If such a property is defined as an auto-property, the [NotMapped] attribute should be used to prevent EF Core from attempting to map such a property to your database. Init-only Properties ​ ​ Properties on Entity Models that use an init accessor rather than a set accessor will be implicitly treated as required, and can also only have a value provided when the entity is created for the first time. Any values provided during save actions for init-only properties when updating an existing entity will be ignored. Entity Models Property Customization ​ ​ For any of the kinds of properties outlined above, the following customizations can be applied: Attributes ​ ​ Coalesce provides a number of Attributes, and supports a number of other .NET attributes, that allow for further customization of your model. Attributes Security ​ ​ Property values received by the server from the client will be ignored if rejected by any property-level Security. This security is implemented in the Generated C# DTOs. property-level Security Generated C# DTOs Loading & Serialization ​ ​ The Default Loading Behavior, any custom functionality defined in Data Sources, and [DtoIncludes] & [DtoExcludes] may also restrict which properties are sent to the client when requested. Default Loading Behavior Data Sources [DtoIncludes] & [DtoExcludes] NotMapped ​ ​ While Coalesce does not do anything special for the [NotMapped] attribute, it is still an important attribute to keep in mind while building your model, as it prevents EF Core from doing anything with the property. Previous pageSecurity Next pageAttributesAttributes ​ ​ Coalesce provides a number of C# attributes that can be used to decorate your model classes and their properties in order to customize behavior, appearance, security, and more. Coalesce also supports a number of annotations from System.ComponentModel.DataAnnotations. Coalesce Attributes ​ ​ Browse the list in the sidebar to learn about the attributes that Coalesce provides that can be used to decorate your models. ComponentModel Attributes ​ ​ Coalesce also supports a number of the built-in System.ComponentModel.DataAnnotations attributes and will use these to shape the generated code. [Display] ​ ​ The displayed name and description of a property, as well as the order in which it appears in generated views, can be set via the [Display] attribute. By default, properties will be displayed in the order in which they are defined in their class. [DisplayName] ​ ​ The displayed name of a property can also be set via the [DisplayName] attribute. [Required] ​ ​ Properties with [Required] will generate client validation and server validation rules. client validation server validation [Range] ​ ​ Properties with [Range] will generate client validation and server validation rules. client validation server validation [MinLength] ​ ​ Properties with [MinLength] will generate client validation and server validation rules. client validation server validation [MaxLength] ​ ​ Properties with [MaxLength] will generate client validation and server validation rules. client validation server validation [DataType] ​ ​ Some values of DataType when provided to DataTypeAttribute on a string property will alter the behavior of the Vue Components. See c-display and See c-display for details. Vue Components c-display c-display [ForeignKey] ​ ​ Normally, Coalesce figures out which properties are foreign keys, but if you don't use standard EF naming conventions then you'll need to annotate with [ForeignKey] to help out both EF and Coalesce. See the Entity Framework Relationships documentation for more. Entity Framework Relationships [InverseProperty] ​ ​ Sometimes, Coalesce (and EF, too) can have trouble figuring out what the foreign key is supposed to be for a collection navigation property. See the Entity Framework Relationships documentation for details on how and why to use [InverseProperty]. Entity Framework Relationships [DatabaseGenerated] ​ ​ Primary Keys with [DatabaseGenerated(DatabaseGeneratedOption.None)] will be settable on the client and will be appropriately handled by the Standard Behaviors on the server. Unsupported on the Knockout front-end stack. Standard Behaviors Knockout front-end stack [NotMapped] ​ ​ Model properties that aren't mapped to the database should be marked with [NotMapped] so that Coalesce doesn't try to load them from the database when searching or carrying out the Default Loading Behavior. searching Default Loading Behavior [DefaultValue] ​ ​ Properties with [DefaultValue] will receive the specified value when a new ViewModel is instantiated on the client. This enables scenarios like pre-filling a required property with a suggested value. Previous pageProperties Next page[ClientValidation][ClientValidation] ​ ​ The [IntelliTect.Coalesce.DataAnnotations.ClientValidation] attribute is used to control the behavior of client-side model validation and to add additional client-only validation parameters. Database validation is available via standard System.ComponentModel.DataAnnotations annotations. These propagate to the client as validations in TypeScript via generated Metadata and ViewModel rules (for Vue) or Knockout-Validation rules (for Knockout). For both stacks, any failing validation rules prevent saves from going to the server. Metadata ViewModel rules Knockout-Validation WARNING This attribute controls client-side validation only. To perform server-side validation, create a custom Behaviors class for your types and/or place C# validation attributes on your models. Read More. Behaviors class Read More Example Usage ​ ​ Properties ​ ​ Behavioral Properties ​ ​ public bool AllowSave { get; set; } // Knockout Only  If set to true, any client validation errors on the property will not prevent saving on the client. This includes all client-side validation, including null-checking for required foreign keys and other validations that are implicit. This also includes other explicit validation from System.ComponentModel.DataAnnotations annotations. Instead, validation errors will be treated only as warnings, and will be available through the warnings: KnockoutValidationErrors property on the TypeScript ViewModel. Note Use AllowSave = true to allow partially complete data to still be saved, protecting your user from data loss upon navigation while still hinting to them that they are not done filling out data. public string ErrorMessage { get; set; }  Set an error message to be used if any client validations fail Validation Rule Properties ​ ​ VueKnockout Vue Knockout In addition to the following properties, you also customize validation on a per-instance basis of the ViewModels using the Rules/Validation methods. ViewModels Rules/Validation The following attribute properties all map directly to Knockout-Validation properties. Knockout-Validation The following attribute properties are outputted to TypeScript unquoted. If you need to assert equality to a string, wrap the value you set to this property in quotes. Other literals (numerics, booleans, etc) need no wrapping. The following two properties may be used together to specify a custom Knockout-Validation property. Knockout-Validation It will be emitted into the TypeScript as this.extend({ CustomName: CustomValue }). Neither value will be quoted in the emitted TypeScript - add quotes to your value as needed to generate valid TypeScript. Previous pageAttributes Next page[Coalesce][Coalesce] ​ ​ Used to mark a type or member for generation by Coalesce. Some types and members will be implicitly included in generation - for example, all types represented by a DbSet<T> on a DbContext that has a [Coalesce] attribute will automatically be included. Properties on these types will also be generated for unless explicitly excluded, since this is by far the most common usage scenario in Coalesce. On the other hand, Methods on these types will not have endpoints generated unless they are explicitly annotated with [Coalesce] to avoid accidentally exposing methods that were perhaps not intended to be exposed. Methods The documentation pages for types and members that require/accept this attribute will state as such. An exhaustive list of all valid targets for [Coalesce] will not be found on this page. Previous page[ClientValidation] Next page[ControllerAction][ControllerAction] ​ ​ Specifies how a custom method is exposed via HTTP. Can be used to customize the HTTP method/verb for the method, as well as caching behavior. custom method Example Usage ​ ​ Properties ​ ​ // Also settable via constructor parameter #1
public HttpMethod Method { get; set; } = HttpMethod.Post;  The HTTP method to use on the generated API Controller. Enum values are: HttpMethod.Post Use the POST method.HttpMethod.Get Use the GET method.HttpMethod.Put Use the PUT method.HttpMethod.Delete Use the DELETE method.HttpMethod.Patch Use the PATCH method. HttpMethod.Post Use the POST method. HttpMethod.Get Use the GET method. HttpMethod.Put Use the PUT method. HttpMethod.Delete Use the DELETE method. HttpMethod.Patch Use the PATCH method. public string VaryByProperty { get; set; }  For HTTP GET model instance methods, if VaryByProperty is set to the name of a property on the parent model class, ETag headers based on the value of this property will be used to implement caching. If the client provides a matching If-None-Match Header with the request, the method will not be invoked and HTTP Status `304 Not Modified`` will be returned. ETag headers Additionally, if the VaryByProperty is set to a client-exposed property, the value of the property will be included in the query string when performing API calls to invoke the method. If the query string value matches the current value on the model, a long-term Cache-Control header will be set on the response, allowing the client to avoid making future invocations to the same method while the value of the VaryByProperty remains the same. property Previous page[Coalesce] Next page[Controller][Controller] ​ ​ Allows for control over the generated MVC Controllers. Currently only controls over the API controllers are present, but additional properties may be added in the future. This attribute may be placed on any type from which an API controller is generated, including Entity Models, Custom DTOs, and Services. Entity Models Custom DTOs Services Example Usage ​ ​ Properties ​ ​ public bool ApiRouted { get; set; } = true;  Determines whether or not a [Route] annotation will be placed on the generated API controller. Set to false to prevent emission of the [Route] attribute. Use cases include: Defining your routes through IRouteBuilder in Startup.cs insteadPreventing API controllers from being exposed by default.Routing to your own custom controller that inherits from the generated API controller in order to implement more granular or complex authorization logic. Defining your routes through IRouteBuilder in Startup.cs instead Preventing API controllers from being exposed by default. Routing to your own custom controller that inherits from the generated API controller in order to implement more granular or complex authorization logic. public string ApiControllerName { get; set; } = null;  If set, will determine the name of the generated API controller. Takes precedence over the value of ApiControllerSuffix. public string ApiControllerSuffix { get; set; } = null;  If set, will be appended to the default name of the API controller generated for this model. Will be overridden by the value of ApiControllerName if it is set. public bool ApiActionsProtected { get; set; } = false;  If true, actions on the generated API controller will have an access modifier of protected instead of public. In order to consume the generated API controller, you must inherit from the generated controller and override each desired generated action method via hiding (i.e. use public new ..., not public override ...). Note If you inherit from the generated API controllers and override their methods without setting ApiActionsProtected = true, all non-overridden actions from the generated controller will still be exposed as normal. Previous page[ControllerAction] Next page[CreateController][CreateController] ​ ​ By default an API and View controller are both created. This allows for suppressing the creation of either or both of these. Example Usage ​ ​ Properties ​ ​ // Also settable via constructor parameter #1
public bool WillCreateView { get; set; } = true  // Also settable via constructor parameter #2
public bool WillCreateApi { get; set; } = true  Previous page[Controller] Next page[DateType][DateType] ​ ​ Specifies whether a DateTime type will have a date and a time, or only a date. Example Usage ​ ​ Properties ​ ​ // Also settable via constructor parameter #1
public DateTypes DateType { get; set; } = DateTypes.DateTime;   The type of date the property represents. Enum values are: DateTypeAttribute.DateTypes.DateTime Subject is both a date and time.DateTypeAttribute.DateTypes.DateOnly Subject is only a date with no significant time component. DateTypeAttribute.DateTypes.DateTime Subject is both a date and time. DateTypeAttribute.DateTypes.DateOnly Subject is only a date with no significant time component. Previous page[CreateController] Next page[DefaultOrderBy][DefaultOrderBy] ​ ​ Allows setting of the default manner in which the data returned to the client will be sorted. Multiple fields can be used to sort an object by specifying an index. This affects the sort order both when requesting a list of the model itself, as well as when the model appears as a child collection off of a navigation property of another object. In the first case (a list of the model itself), this can be overridden by setting the orderBy or orderByDescending property on the TypeScript ListViewModel - see TypeScript List ViewModels. TypeScript List ViewModels Example Usage ​ ​ Properties ​ ​ // Also settable via constructor parameter #1
public int FieldOrder { get; set; } = 0;   Specify the index of this field when sorting by multiple fields. Lower-valued properties will be used first; higher-valued properties will be used as a tiebreaker (i.e. .ThenBy(...)). // Also settable via constructor parameter #2
public OrderByDirections OrderByDirection { get; set; } = OrderByDirections.Ascending;  Specify the direction of the ordering for the property. Enum values are: DefaultOrderByAttribute.OrderByDirections.AscendingDefaultOrderByAttribute.OrderByDirections.Descending DefaultOrderByAttribute.OrderByDirections.Ascending DefaultOrderByAttribute.OrderByDirections.Descending public string FieldName { get; set; }  When using the DefaultOrderByAttribute on an object property, specifies the field on the object to use for sorting. See the first example above. Previous page[DateType] Next page[DtoIncludes] & [DtoExcludes][DtoIncludes] & [DtoExcludes] ​ ​ Allows for easily controlling what data gets set to the client. When requesting data from the generated client-side list view models, you can specify an includes property on the ViewModel or ListViewModel. For more information about the includes string, see Includes String. Includes String When the database entries are returned to the client they will be trimmed based on the requested includes string and the values in DtoExcludes and DtoIncludes. DANGER These attributes are not security attributes - consumers of your application's API can set the includes string to any value when making a request. Do not use them to keep certain data private - use the Security Attributes family of attributes for that. Security Attributes It is important to note that the value of the includes string will match against these attributes on any of your models that appears in the object graph being mapped to DTOs - it is not limited only to the model type of the root object. Important DtoIncludes does not ensure that specific data will be loaded from the database. It only permits what is already loaded into the current EF DbContext to be returned from the API. See Data Sources to learn how to control what data gets loaded from the database. Data Sources Example Usage ​ ​ Server code: Client code: VueKnockout Vue Knockout Properties ​ ​ // Also settable via constructor parameter #1
public string ContentViews { get; set; }  A comma-delimited list of values of includes on which to operate. includes For DtoIncludes, this will be the values of includes for which this property will be allowed to be serialized and sent to the client. For DtoExcludes, this will be the values of includes for which this property will not be serialized and sent to the client. Previous page[DefaultOrderBy] Next page[Execute][Execute] ​ ​ Controls permissions for executing of a static or instance method through the API. For other security controls, see Security Attributes. Security Attributes Example Usage ​ ​ Properties ​ ​ public string Roles { get; set; }  A comma-separated list of roles which are allowed to execute the method. public SecurityPermissionLevels PermissionLevel { get; set; } = SecurityPermissionLevels.AllowAuthorized;  The level of access to allow for the action for the method. Enum values are: SecurityPermissionLevels.AllowAll Allow all users to perform the action for the attribute, including users who are not authenticated at all.SecurityPermissionLevels.AllowAuthorized Allow only users who are members of the roles specified on the attribute to perform the action. If no roles are specified on the attribute, then all authenticated users are allowed (no anonymous access).SecurityPermissionLevels.DenyAll Deny the action to all users, regardless of authentication status or authorization level. If DenyAll is used, no API endpoint for the action will be generated. SecurityPermissionLevels.AllowAll Allow all users to perform the action for the attribute, including users who are not authenticated at all. SecurityPermissionLevels.AllowAuthorized Allow only users who are members of the roles specified on the attribute to perform the action. If no roles are specified on the attribute, then all authenticated users are allowed (no anonymous access). SecurityPermissionLevels.DenyAll Deny the action to all users, regardless of authentication status or authorization level. If DenyAll is used, no API endpoint for the action will be generated. public bool AutoClear { get; set; }  If true, the method's arguments will be cleared after a successful invocation on admin pages. public bool? ValidateAttributes { get; set; }  If non-null, overrides the value of CoalesceOptions.ValidateAttributesForMethods when determining whether to perform automatic server-side validation of the method's parameters. CoalesceOptions.ValidateAttributesForMethods If validation is performed, the method's parameters will be validated by the server and the method invocation prevented if errors are found. Previous page[DtoIncludes] & [DtoExcludes] Next page[Hidden][Hidden] ​ ​ Mark an property as hidden from the edit, List or All areas. DANGER This attribute is not a security attribute - it only affects the rendering of the admin pages. It has no impact on data visibility in the API. Do not use it to keep certain data private - use the Security Attributes family of attributes for that. Security Attributes Example Usage ​ ​ Properties ​ ​ // Also settable via constructor parameter #1
public Areas Area { get; set; } = Areas.All;  The areas in which the property should be hidden. Enum values are: HiddenAttribute.Areas.None Hide from no generated views. Primary and Foreign keys are hidden by default - setting this value explicitly can override this default behavior.HiddenAttribute.Areas.All Hide from all generated viewsHiddenAttribute.Areas.List Hide from generated list views only (Knockout Table/Cards, Vue c-admin-table)HiddenAttribute.Areas.Edit Hide from generated editor only (Knockout CreateEdit, Vue c-admin-editor) HiddenAttribute.Areas.None Hide from no generated views. Primary and Foreign keys are hidden by default - setting this value explicitly can override this default behavior. HiddenAttribute.Areas.All Hide from all generated views HiddenAttribute.Areas.List Hide from generated list views only (Knockout Table/Cards, Vue c-admin-table) HiddenAttribute.Areas.Edit Hide from generated editor only (Knockout CreateEdit, Vue c-admin-editor) Previous page[Execute] Next page[Inject][Inject] ​ ​ Used to mark a Method parameter for dependency injection from the application's IServiceProvider. Method See Methods for more. Methods This gets translated to a Microsoft.AspNetCore.Mvc.FromServicesAttribute in the generated API controller's action. Example Usage ​ ​ Previous page[Hidden] Next page[InternalUse][InternalUse] ​ ​ Used to mark a type, property or method for internal use. Internal Use members are: Not exposed via the API.Not present in the generated TypeScript view models.Not present nor accounted for in the generated C# DTOs.Not present in the generated editor or list views. Not exposed via the API. Not present in the generated TypeScript view models. Not present nor accounted for in the generated C# DTOs. Not present in the generated editor or list views. Effectively, an Internal Use member is invisible to Coalesce. This attribute can be considered a Security Attribute. Security Attribute Note that this only needs to be used on members that are public. Non-public members (including internal) are always invisible to Coalesce. Example Usage ​ ​ In this example, Color is the property exposed to the API, but ColorHex is the property that maps to the database that stores the value. A helper method also exists for the color generation, but needs no attribute to be hidden since methods must be explicitly exposed with [Coalesce]. [Coalesce] If no color is saved in the database (the user hasn't picked a color), one is deterministically created. Previous page[Inject] Next page[ListText][ListText] ​ ​ When a textual representation of an object needs to be displayed in the UI, this attribute controls which property will be used. Examples include dropdowns and cells in admin UI tables. If this attribute is not used, and a property named Name exists on the model, that property will be used. Otherwise, the primary key will be used. Example Usage ​ ​ Previous page[InternalUse] Next page[LoadFromDataSource][LoadFromDataSource] ​ ​ Specifies that the targeted model instance method should load the instance it is called on from the specified data source when invoked from an API endpoint. If not defined, the model's default data source is used. Example Usage ​ ​ Properties ​ ​ // ONLY settable via constructor parameter #1
public Type DataSourceType { get; }  The name of the Data Source to load the instance object from. Data Source Previous page[ListText] Next page[ManyToMany][ManyToMany] ​ ​ Used to specify a Many to Many relationship. Because EF core does not support automatic intermediate mapping tables, this field is used to allow for direct reference of the many-to-many collections from the ViewModel. The named specified in the attribute will be used as the name of a collection of the objects on the other side of the relationship in the generated TypeScript ViewModels. TypeScript ViewModels Example Usage ​ ​ Properties ​ ​ // ONLY settable via constructor parameter #1
public string CollectionName { get; }  The name of the collection that will contain the set of objects on the other side of the many-to-many relationship. public string FarNavigationProperty { get; set; }  The name of the navigation property on the middle entity that points at the far side of the many-to-many relationship. Use this to resolve ambiguities when the middle table of the many-to-many relationship has more than two reference navigation properties on it. Previous page[LoadFromDataSource] Next page[Restrict][Restrict] ​ ​ In addition to role-based property restrictions, you can also define property restrictions that can execute custom code for each model instance if your logic require more nuanced decisions than can be made with roles. role-based Restriction classes support dependency injection, so you can inject any supplemental services needed to make a determination. The UserCanRead method controls whether values of the restricted property will be mapped from model instances to the generated DTO. Similarly, UserCanWrite controls whether the property can be mapped back to the model instance from the generated DTO. The UserCanFilter method has a default implementation that returns false, but can be implemented if there is an appropriate, instance-agnostic way to determine if a user can sort, search, or filter values of that property. Multiple different restrictions can be placed on a single property; all of them must succeed for the operation to be permitted. Restrictions also stack on top of role attribute restrictions ([Read] and [Edit]). A non-generic variant of IPropertyRestriction also exists for restrictions that might be reused across multiple model types. Previous page[ManyToMany] Next page[Search][Search] ​ ​ Coalesce supports searching through the generated API in its various implementations, including the generated list views (Table & Cards), in Select2 dropdowns, and directly through the TypeScript ListViewModels' search property. The search parameter of the API can also be formatted as PropertyName:SearchTerm in order to search on an arbitrary property of a model. For example, a value of Nickname:Steve-o for a search term would search the Nickname property, even through it is not marked as searchable using this attribute. By default, the system will search any field with the name 'Name'. If this doesn't exist, the ID is used as the only searchable field. Once you place the Search attribute on one or more properties on a model, only those annotated properties will be searched. Searchable Property Types ​ ​ Strings ​ ​ String fields will be searched based on the SearchMethod property on the attribute. See below. Numeric Types ​ ​ If the input is numeric, numeric fields will be searched for the exact value. Enums ​ ​ If the input is a valid name of an enum value for an enum property and that property is searchable, rows will be searched for the exact value. Dates ​ ​ If the input is a parsable date, rows will be searched based on that date. Date search will do its best to guess at the user's intentions: Various forms of year/month combos are supported, and if only a year/month is inputted, it will look for all dates in that month, e.g. "Feb 2017" or "2016-11".A date without a time (or a time of exactly midnight) will search the entire day, e.g. "2017/4/18".A date/time with minutes and seconds equal to 0 will search the entire hour, e.g. "April 7, 2017 11 AM". Various forms of year/month combos are supported, and if only a year/month is inputted, it will look for all dates in that month, e.g. "Feb 2017" or "2016-11". A date without a time (or a time of exactly midnight) will search the entire day, e.g. "2017/4/18". A date/time with minutes and seconds equal to 0 will search the entire hour, e.g. "April 7, 2017 11 AM". TIP When searching on date properties, you should almost always set IsSplitOnSpaces = false on the Search attribute. This allows natural inputs like "July 21, 2017" to search correctly. Otherwise, only non-whitespace date formats will work, like "2017/21/07". Reference Navigation Properties ​ ​ When a reference navigation property is marked with [Search], searchable properties on the referenced object will also be searched. This behavior will go up to two levels away from the root object, and can be controlled with the RootWhitelist and RootBlacklist properties on the [Search] attribute that are outlined below. Collection Navigation Properties ​ ​ When a collection navigation property is marked with [Search], searchable properties on the child objects will also be searched. This behavior will go up to two levels away from the root object, and can be controlled with the RootWhitelist and RootBlacklist properties on the [Search] attribute that are outlined below. WARNING Searches on collection navigation properties usually don't translate well with EF Core, leading to potentially degraded performance. Use this feature cautiously. Example Usage ​ ​ Properties ​ ​ public bool IsSplitOnSpaces { get; set; } = true;  If set to true (the default), each word in the search terms will be searched for in each searchable field independently, and a row will only be considered a match if each word in the search term is a match on at least one searchable property where IsSplitOnSpaces == true This is useful when searching for a full name across two or more fields. In the above example, using IsSplitOnSpaces = true would provide more intuitive behavior since it will search both first name and last name for each word entered into the search field. But, you probably shouldn't be doing that. you probably shouldn't be doing that public SearchMethods SearchMethod { get; set; } = SearchMethods.BeginsWith;  For string properties, specifies how the value in the property/column will be matched. BeginsWith: Search term will be checked for at the beginning of the field's value in a case insensitive manner.Equals: Search term must match the field exactly in a case insensitive manner.EqualsNatural: Search term must match exactly, using the natural casing handling of the evaluation environment. Default database collation will be used if evaluated in SQL, and exact casing will be used if evaluated in memory. This allows index seeks to be used instead of index scans, providing extra high performance searches against indexed columnsContains: Search term will be checked for anywhere inside the field's value in a case insensitive manner. Will be slow against large databases - performance cannot be improved with database indexing. BeginsWith: Search term will be checked for at the beginning of the field's value in a case insensitive manner. Equals: Search term must match the field exactly in a case insensitive manner. EqualsNatural: Search term must match exactly, using the natural casing handling of the evaluation environment. Default database collation will be used if evaluated in SQL, and exact casing will be used if evaluated in memory. This allows index seeks to be used instead of index scans, providing extra high performance searches against indexed columns Contains: Search term will be checked for anywhere inside the field's value in a case insensitive manner. Will be slow against large databases - performance cannot be improved with database indexing. public string RootWhitelist { get; set; } = null;  A comma-delimited list of model class names that, if set, will prevent the targeted property from being searched unless the root object of the API call was one of the specified class names. public string RootBlacklist { get; set; } = null;  A comma-delimited list of model class names that, if set, will prevent the targeted property from being searched if the root object of the API call was one of the specified class names. Previous page[Restrict] Next pageSecurity AttributesSecurity Attributes ​ ​ Coalesce provides a collection of attributes which can provide class-level (and property-level, where appropriate) security controls over the generated API. TIP This page provides API-level documentation for a specific set of attributes. For a complete overview of all the security-focused techniques that can be used in a Coalesce application, see the Security page. Security Class vs. Property Security ​ ​ There are important differences between class-level security and property-level security, beyond the usage of the attributes themselves. In general, class-level security is implemented in the generated API Controllers as [Authorize] attributes on the generated actions. Property security attributes are implemented in the Generated C# DTOs. Generated C# DTOs Implementations ​ ​ [Read] ​ ​ Controls permissions for reading of objects and properties through the API. For property-level security only, if a [Read] attribute is present without an [Edit] attribute, the property is read-only. Additionally, you can set NoAutoInclude = true the [Read] attribute to suppress the Default Loading Behavior. Default Loading Behavior Example Usage ​ ​ [Edit] ​ ​ Controls permissions for editing of objects and properties through the API. For property-level security only, if a [Read] attribute is present, one of its roles must be fulfilled in addition to the roles specified (if any) for the [Edit] attribute. Example Usage ​ ​ [Create] ​ ​ Controls permissions for creation of an object of the targeted type through the API. Example Usage ​ ​ [Delete] ​ ​ Controls permissions for deletion of an object of the targeted type through the API. Example Usage ​ ​ [Execute] ​ ​ A separate attribute for controlling method execution exists. Its documentation may be found on the [Execute] page. [Execute] [Restrict] ​ ​ For property security, [Read] and [Edit] can be used to apply role-based security. If you need logic more complicated than checking for the presence of a role, [Restrict] offers the ability to write custom code to control the read and/or write permissions of a property. [Restrict] Attribute Properties ​ ​ // Also settable via constructor parameter #1
public string Roles { get; set; }  A comma-delimited list of roles that are authorized to take perform the action represented by the attribute. If the current user belongs to any of the listed roles, the action will be allowed. The string set for this property will be outputted as an [Authorize(Roles="RolesString")] attribute on generated API controller actions. // Also settable via constructor parameter #2
public SecurityPermissionLevels PermissionLevel { get; set; }  The level of access to allow for the action for class-level security only. Has no effect for property-level security. Enum values are: SecurityPermissionLevels.AllowAll Allow all users to perform the action for the attribute, including users who are not authenticated at all.SecurityPermissionLevels.AllowAuthorized Allow only users who are members of the roles specified on the attribute to perform the action. If no roles are specified on the attribute, then all authenticated users are allowed (no anonymous access).SecurityPermissionLevels.DenyAll Deny the action to all users, regardless of authentication status or authorization level. If DenyAll is used, no API endpoint for the action will be generated. SecurityPermissionLevels.AllowAll Allow all users to perform the action for the attribute, including users who are not authenticated at all. SecurityPermissionLevels.AllowAuthorized Allow only users who are members of the roles specified on the attribute to perform the action. If no roles are specified on the attribute, then all authenticated users are allowed (no anonymous access). SecurityPermissionLevels.DenyAll Deny the action to all users, regardless of authentication status or authorization level. If DenyAll is used, no API endpoint for the action will be generated. Previous page[Search] Next page[SelectFilter][SelectFilter] ​ ​ WARNING This attribute only affects the generated Knockout HTML views - it does not enforce any relational rules in your data. This attribute also currently has no effect against the Vue stack. Specify a property to restrict dropdown menus by. Values presented will be only those where the value of the foreign property matches the value of the local property. The local property name defaults to the same value of the foreign property. Additionally, in place of a LocalPropertyName to check against, you may instead specify a static value using StaticPropertyValue to filter by a constant. Example Usage ​ ​ In this example, a dropdown for EmployeeRank created using @Knockout.SelectForObject in cshtml files will only present possible values of EmployeeRank which are valid for the EmployeeType of the Employee. Properties ​ ​ public string ForeignPropertyName { get; set; }  The name of the property on the foreign object to filter against. public string LocalPropertyName { get; set; }  The name of another property belonging to the class in which this attribute is used. The results of select lists will be filtered to match this value. Defaults to the value of ForeignPropertyName if not set. public string LocalPropertyObjectName { get; set; }  If specified, the LocalPropertyName will be resolved from the property by this name that resides on the local object. This allows for querying against properties that are one level away from the current object. public string StaticPropertyValue { get; set; }  A constant value that the foreign property will be filtered against. This string must be parsable into the foreign property's type to have any effect. If this is set, LocalPropertyName will be ignored. Previous pageSecurity Attributes Next page[TypeScriptPartial][TypeScriptPartial] ​ ​ Note This attribute only applies to the Knockout front-end stack. It is not applicable to the Vue stack. If defined on a model, a typescript file will be generated in ./Scripts/Partials if one does not already exist. This 'Partial' TypeScript file contains a class which inherits from the generated TypeScript ViewModel. The partial class has the same name as the generated ViewModel would normally have, and the generated ViewModel is renamed to "<ClassName>Partial". This behavior allows you to extend the behavior of the generated TypeScript view models with your own properties and methods for defining more advanced behavior on the client. One of the most common use cases of this is to define additional Knockout ComputedObservable properties for information that is only useful in the browser - for example, computing a css class based on data in the object. Example Usage ​ ​ Properties ​ ​ public string BaseClassName { get; set; }  If set, overrides the name of the generated ViewModel which becomes the base class for the generated 'Partial' TypeScript file. Previous page[SelectFilter] Next pageMethodsMethods ​ ​ Any public methods annotated with the [Coalesce] attribute that are placed on your model classes will have API endpoints and Typescript generated by Coalesce. Both instance methods and static methods are supported. Additionally, any instance methods on Services will also have API endpoints and TypeScript generated. [Coalesce] Services These custom methods allow you to implement any custom server-side functionality in your Coalesce application that falls outside of the standard CRUD functions that are generated for your entities. Declaring Methods ​ ​ Instance Methods ​ ​ Instance Methods can be declared on your Entity classes. For example: Entity classes When an instance method is invoked, the target model instance will be loaded using the data source specified by an attribute [LoadFromDataSource(typeof(MyDataSource))] if present. Otherwise, the model instance will be loaded using the default data source for the model's type. If you have a Custom Data Source annotated with [DefaultDataSource], that data source will be used. Otherwise, the Standard Data Source will be used. The consequence of this is that a user cannot call a method on an instance of entity that they're not allowed to see or load. Custom Data Source Standard Data Source Instance methods are generated onto the TypeScript ViewModels. When should I use Instance Methods? ​ ​ Instance methods, as opposed to static or service methods, are a good fit when implementing an action that directly acts on or depends upon a specific instance of one of your entity types. One of their biggest benefits is the automatic row-level security from data sources as described above. static service Static Methods ​ ​ Static Methods can be declared on your Entity classes. For example: Entity classes Static methods are generated onto the TypeScript ListViewModels. All of the same members that are generated for instance methods are also generated for static methods. When should I use Static Methods? ​ ​ Static methods are a good fit for actions that don't operate on a specific instance of an entity type, but whose functionality is still closely coupled with a specific, concrete entity type. For example, imagine you have a File entity class. You could make a static method on that class that accepts a file as a parameter. This method would persist that file to storage and then save a new entity to the database. You would then disable Create on that entity, since the default /save endpoint cannot accept file uploads. disable Create Or, imagine an Invoice class. You might make a static method that returns a summary of sales information for a given time range. Since this summarization would be performing aggregate functions against your Invoice entities and is therefore tightly coupled to Invoices, a static method would be suitable. Service Methods ​ ​ Service methods can be declared on a Coalesce Service class: Coalesce Service Or, they can be declared via a Coalesce Service interface that has an implementation registered with dependency injection: Coalesce Service When declaring service methods by interface, a [Coalesce] attribute on each method is not needed - the entire interface is exposed by Coalesce. When should I use Service Methods? ​ ​ Services are a catch-all feature and can be used for almost any conceivable purpose in Coalesce to implement custom functionality that needs to be invoked by your front-end app. Services However, there are some reasons why you might not want to use a service: If the method logically operates on a single entity instance, and/or if using an instance method would let you utilize the row-level security already implemented by one of your data sources to authorize who can invoke the method.If the service would only have one or two methods and would logically make sense as a static or instance method. In other words, if adding a new service class would be detrimental to the organization of your codebase and create "file sprawl". If the method logically operates on a single entity instance, and/or if using an instance method would let you utilize the row-level security already implemented by one of your data sources to authorize who can invoke the method. If the service would only have one or two methods and would logically make sense as a static or instance method. In other words, if adding a new service class would be detrimental to the organization of your codebase and create "file sprawl". On the other hand, services have some benefits that instance and static methods cannot provide: Coalesce Services can be declared with an interface, rather than a concrete type, allowing for their implementation to be substituted more easily. For example, a service providing an external integration that you want to mock or stub during automated testing and/or local development. Coalesce Services can be declared with an interface, rather than a concrete type, allowing for their implementation to be substituted more easily. For example, a service providing an external integration that you want to mock or stub during automated testing and/or local development. Parameters ​ ​ The following parameters can be added to your methods: TypeDescriptionPrimitives, Dates, and other ScalarsMost common built-in primitive and scalar data types (numerics, strings, booleans, enums, DateTime, DateTimeOffset), and their nullable variants, are accepted as parameters to be passed from the client to the method call.Entity ModelsWhen invoking the method on the client, the object's properties will only be serialized one level deep. If an entity model parameter has additional child object properties, they will not be included in the invocation of the method - only the object's primitive & date properties will be deserialized from the client.External TypesUnlike entity model parameters, external type parameters will be serialized and sent by the client to an arbitrarily deep level, excluding any entity model properties that may be nested inside an external type.FilesMethods can accept file uploads by using a parameter of type IntelliTect.Coalesce.Models.IFile (or any derived type, like IntelliTect.Coalesce.Models.File).ICollection<T>, IEnumerable<T>Collections of any of the above valid parameter types above are also valid parameter types.DbContextIf the method has a parameter assignable to Microsoft.EntityFrameworkCore.DbContext, then the parameter will be implicitly [Inject]ed.ClaimsPrincipalIf the method has a parameter of type ClaimsPrincipal, the value of HttpContext.User will be passed to the parameter.[Inject]If a parameter is marked with the [Inject] attribute, it will be injected from the application's IServiceProvider.out IncludeTreeDeprecated. If you need to return an Include Tree to shape the serialization of the method's return value, you should use an ItemResult<T> return value and populate the IncludeTree property on the ItemResult object. TypeDescription Type Description Primitives, Dates, and other ScalarsMost common built-in primitive and scalar data types (numerics, strings, booleans, enums, DateTime, DateTimeOffset), and their nullable variants, are accepted as parameters to be passed from the client to the method call. Primitives, Dates, and other Scalars Primitives, Dates, and other Scalars Most common built-in primitive and scalar data types (numerics, strings, booleans, enums, DateTime, DateTimeOffset), and their nullable variants, are accepted as parameters to be passed from the client to the method call. Most common built-in primitive and scalar data types (numerics, strings, booleans, enums, DateTime, DateTimeOffset), and their nullable variants, are accepted as parameters to be passed from the client to the method call. Entity ModelsWhen invoking the method on the client, the object's properties will only be serialized one level deep. If an entity model parameter has additional child object properties, they will not be included in the invocation of the method - only the object's primitive & date properties will be deserialized from the client. Entity Models Entity Models Entity Models When invoking the method on the client, the object's properties will only be serialized one level deep. If an entity model parameter has additional child object properties, they will not be included in the invocation of the method - only the object's primitive & date properties will be deserialized from the client. When invoking the method on the client, the object's properties will only be serialized one level deep. If an entity model parameter has additional child object properties, they will not be included in the invocation of the method - only the object's primitive & date properties will be deserialized from the client. External TypesUnlike entity model parameters, external type parameters will be serialized and sent by the client to an arbitrarily deep level, excluding any entity model properties that may be nested inside an external type. External Types External Types External Types Unlike entity model parameters, external type parameters will be serialized and sent by the client to an arbitrarily deep level, excluding any entity model properties that may be nested inside an external type. Unlike entity model parameters, external type parameters will be serialized and sent by the client to an arbitrarily deep level, excluding any entity model properties that may be nested inside an external type. FilesMethods can accept file uploads by using a parameter of type IntelliTect.Coalesce.Models.IFile (or any derived type, like IntelliTect.Coalesce.Models.File). Files Files Methods can accept file uploads by using a parameter of type IntelliTect.Coalesce.Models.IFile (or any derived type, like IntelliTect.Coalesce.Models.File). Methods can accept file uploads by using a parameter of type IntelliTect.Coalesce.Models.IFile (or any derived type, like IntelliTect.Coalesce.Models.File). ICollection<T>, IEnumerable<T>Collections of any of the above valid parameter types above are also valid parameter types. ICollection<T>, IEnumerable<T> ICollection<T>, IEnumerable<T> ICollection<T> IEnumerable<T> Collections of any of the above valid parameter types above are also valid parameter types. Collections of any of the above valid parameter types above are also valid parameter types. DbContextIf the method has a parameter assignable to Microsoft.EntityFrameworkCore.DbContext, then the parameter will be implicitly [Inject]ed. DbContext DbContext DbContext If the method has a parameter assignable to Microsoft.EntityFrameworkCore.DbContext, then the parameter will be implicitly [Inject]ed. If the method has a parameter assignable to Microsoft.EntityFrameworkCore.DbContext, then the parameter will be implicitly [Inject]ed. ClaimsPrincipalIf the method has a parameter of type ClaimsPrincipal, the value of HttpContext.User will be passed to the parameter. ClaimsPrincipal ClaimsPrincipal ClaimsPrincipal If the method has a parameter of type ClaimsPrincipal, the value of HttpContext.User will be passed to the parameter. If the method has a parameter of type ClaimsPrincipal, the value of HttpContext.User will be passed to the parameter. [Inject]If a parameter is marked with the [Inject] attribute, it will be injected from the application's IServiceProvider. [Inject] [Inject] [Inject] If a parameter is marked with the [Inject] attribute, it will be injected from the application's IServiceProvider. If a parameter is marked with the [Inject] attribute, it will be injected from the application's IServiceProvider. [Inject] out IncludeTreeDeprecated. If you need to return an Include Tree to shape the serialization of the method's return value, you should use an ItemResult<T> return value and populate the IncludeTree property on the ItemResult object. out IncludeTree out IncludeTree IncludeTree Deprecated. If you need to return an Include Tree to shape the serialization of the method's return value, you should use an ItemResult<T> return value and populate the IncludeTree property on the ItemResult object. Deprecated. If you need to return an Include Tree to shape the serialization of the method's return value, you should use an ItemResult<T> return value and populate the IncludeTree property on the ItemResult object. Include Tree Return Values ​ ​ You can return virtually anything from these methods: TypeDescriptionPrimitives, Dates, and other ScalarsMost common built-in primitive and scalar data types (numerics, strings, booleans, enums, DateTime, DateTimeOffset), and their nullable variants, may be returned from methods.Entity ModelsAny of the types of your models may be returned.External TypesAny External Types you define may also be returned from a method.When returning custom types from methods, be careful of the types of their properties. Coalesce will recursively discover and generate code for all public properties of your External Types. If you accidentally include a type that you do not own, these generated types could get out of hand extremely quickly.Mark any properties you don't want generated with the [InternalUse] attribute, or give them a non-public access modifier. Whenever possible, don't return types that you don't own or control.ICollection<T>, IEnumerable<T>Collections of any of the above valid return types above are also valid return types. IEnumerables are useful for generator functions using yield. ICollection is highly suggested over IEnumerable whenever appropriate, though.IQueryable<T>Queryables of the valid return types above are valid return types. The query will be evaluated, and Coalesce will attempt to pull an Include Tree from the queryable to shape the response.When Include Tree functionality is needed to shape the response but an IQueryable<> return type is not feasible, an ItemResult return value with an IncludeTree set on it will do the trick as well.FilesMethods can return file downloads using type IntelliTect.Coalesce.Models.IFile (or any derived type, like IntelliTect.Coalesce.Models.File).Please see the File Downloads section below for more detailsItemResult<T>, ItemResult, ListResult<T>An IntelliTect.Coalesce.Models.ItemResult<T> of any of the valid return types above, including collections, is valid, as well as its non-generic variant ItemResult, and its list variant ListResult<T>.Use an ItemResult whenever you might need to signal failure and return an error message from a custom method. The WasSuccessful and Message properties on the result object will be sent along to the client to indicate success or failure of the method. The type T will be mapped to the appropriate DTO object before being serialized as normal.An Include Tree can be set on the object's IncludeTree parameter to shape the serialization of the method's returned value. TypeDescription Type Description Primitives, Dates, and other ScalarsMost common built-in primitive and scalar data types (numerics, strings, booleans, enums, DateTime, DateTimeOffset), and their nullable variants, may be returned from methods. Primitives, Dates, and other Scalars Primitives, Dates, and other Scalars Most common built-in primitive and scalar data types (numerics, strings, booleans, enums, DateTime, DateTimeOffset), and their nullable variants, may be returned from methods. Most common built-in primitive and scalar data types (numerics, strings, booleans, enums, DateTime, DateTimeOffset), and their nullable variants, may be returned from methods. Entity ModelsAny of the types of your models may be returned. Entity Models Entity Models Entity Models Any of the types of your models may be returned. Any of the types of your models may be returned. External TypesAny External Types you define may also be returned from a method.When returning custom types from methods, be careful of the types of their properties. Coalesce will recursively discover and generate code for all public properties of your External Types. If you accidentally include a type that you do not own, these generated types could get out of hand extremely quickly.Mark any properties you don't want generated with the [InternalUse] attribute, or give them a non-public access modifier. Whenever possible, don't return types that you don't own or control. External Types External Types External Types Any External Types you define may also be returned from a method.When returning custom types from methods, be careful of the types of their properties. Coalesce will recursively discover and generate code for all public properties of your External Types. If you accidentally include a type that you do not own, these generated types could get out of hand extremely quickly.Mark any properties you don't want generated with the [InternalUse] attribute, or give them a non-public access modifier. Whenever possible, don't return types that you don't own or control. Any External Types you define may also be returned from a method. External Types When returning custom types from methods, be careful of the types of their properties. Coalesce will recursively discover and generate code for all public properties of your External Types. If you accidentally include a type that you do not own, these generated types could get out of hand extremely quickly. External Types Mark any properties you don't want generated with the [InternalUse] attribute, or give them a non-public access modifier. Whenever possible, don't return types that you don't own or control. [InternalUse] ICollection<T>, IEnumerable<T>Collections of any of the above valid return types above are also valid return types. IEnumerables are useful for generator functions using yield. ICollection is highly suggested over IEnumerable whenever appropriate, though. ICollection<T>, IEnumerable<T> ICollection<T>, IEnumerable<T> ICollection<T> IEnumerable<T> Collections of any of the above valid return types above are also valid return types. IEnumerables are useful for generator functions using yield. ICollection is highly suggested over IEnumerable whenever appropriate, though. Collections of any of the above valid return types above are also valid return types. IEnumerables are useful for generator functions using yield. ICollection is highly suggested over IEnumerable whenever appropriate, though. IQueryable<T>Queryables of the valid return types above are valid return types. The query will be evaluated, and Coalesce will attempt to pull an Include Tree from the queryable to shape the response.When Include Tree functionality is needed to shape the response but an IQueryable<> return type is not feasible, an ItemResult return value with an IncludeTree set on it will do the trick as well. IQueryable<T> IQueryable<T> IQueryable<T> Queryables of the valid return types above are valid return types. The query will be evaluated, and Coalesce will attempt to pull an Include Tree from the queryable to shape the response.When Include Tree functionality is needed to shape the response but an IQueryable<> return type is not feasible, an ItemResult return value with an IncludeTree set on it will do the trick as well. Queryables of the valid return types above are valid return types. The query will be evaluated, and Coalesce will attempt to pull an Include Tree from the queryable to shape the response. Include Tree When Include Tree functionality is needed to shape the response but an IQueryable<> return type is not feasible, an ItemResult return value with an IncludeTree set on it will do the trick as well. Include Tree FilesMethods can return file downloads using type IntelliTect.Coalesce.Models.IFile (or any derived type, like IntelliTect.Coalesce.Models.File).Please see the File Downloads section below for more details Files Files Files Methods can return file downloads using type IntelliTect.Coalesce.Models.IFile (or any derived type, like IntelliTect.Coalesce.Models.File).Please see the File Downloads section below for more details Methods can return file downloads using type IntelliTect.Coalesce.Models.IFile (or any derived type, like IntelliTect.Coalesce.Models.File). Please see the File Downloads section below for more details File Downloads ItemResult<T>, ItemResult, ListResult<T>An IntelliTect.Coalesce.Models.ItemResult<T> of any of the valid return types above, including collections, is valid, as well as its non-generic variant ItemResult, and its list variant ListResult<T>.Use an ItemResult whenever you might need to signal failure and return an error message from a custom method. The WasSuccessful and Message properties on the result object will be sent along to the client to indicate success or failure of the method. The type T will be mapped to the appropriate DTO object before being serialized as normal.An Include Tree can be set on the object's IncludeTree parameter to shape the serialization of the method's returned value. ItemResult<T>, ItemResult, ListResult<T> ItemResult<T>, ItemResult, ListResult<T> An IntelliTect.Coalesce.Models.ItemResult<T> of any of the valid return types above, including collections, is valid, as well as its non-generic variant ItemResult, and its list variant ListResult<T>.Use an ItemResult whenever you might need to signal failure and return an error message from a custom method. The WasSuccessful and Message properties on the result object will be sent along to the client to indicate success or failure of the method. The type T will be mapped to the appropriate DTO object before being serialized as normal.An Include Tree can be set on the object's IncludeTree parameter to shape the serialization of the method's returned value. An IntelliTect.Coalesce.Models.ItemResult<T> of any of the valid return types above, including collections, is valid, as well as its non-generic variant ItemResult, and its list variant ListResult<T>. Use an ItemResult whenever you might need to signal failure and return an error message from a custom method. The WasSuccessful and Message properties on the result object will be sent along to the client to indicate success or failure of the method. The type T will be mapped to the appropriate DTO object before being serialized as normal. An Include Tree can be set on the object's IncludeTree parameter to shape the serialization of the method's returned value. Include Tree Security ​ ​ You can implement role-based security on a method by placing the [Execute] on the method. Placing this attribute on the method with no roles specified will simply require that the calling user be authenticated. [Execute] Security for instance methods is also controlled by the data source that loads the instance - if the data source can't provide an instance of the requested model, the method won't be executed. See the Security page to read more about custom method security, as well as all other security mechanisms in Coalesce. Security Generated TypeScript ​ ​ See API Callers and ViewModel Layer for details on the code that is generated for your custom methods. API Callers ViewModel Layer Note Any Task-returning methods with "Async" as a suffix to the C# method's name will have the "Async" suffix stripped from the generated Typescript. Method Annotations ​ ​ Methods can be annotated with attributes to control API exposure and TypeScript generation. The following attributes are available for model methods. General annotations can be found on the Attributes page. Attributes [Coalesce] ​ ​ The [Coalesce] attribute causes the method to be exposed via a generated API controller. This is not needed for methods defined on an interface marked with [Service] - Coalesce assumes that all methods on the interface are intended to be exposed. If this is not desired, create a new, more restricted interface with only the desired methods to be exposed. [Coalesce] [ControllerAction(Method = HttpMethod, VaryByProperty = string)] ​ ​ The [ControllerAction] attribute controls how this method is exposed via HTTP. Can be used to customize the HTTP method/verb for the method, as well as caching behavior. [ControllerAction] [Execute(string roles)] ​ ​ The [Execute] attribute specifies which roles can execute this method from the generated API controller. Additional security restrictions that cannot be implemented with roles should be enforced with custom code in the method's implementation. [Execute] [LoadFromDataSource(Type dataSourceType)] ​ ​ The [LoadFromDataSource] attribute specifies that the targeted model instance method should load the instance it is called on from the specified data source when invoked from an API endpoint. If not defined, the model's default data source is used. [LoadFromDataSource] File Downloads ​ ​ Coalesce supports exposing file downloads via custom methods. Simply return a IntelliTect.Coalesce.Models.IFile (or any derived type, like IntelliTect.Coalesce.Models.File), or an ItemResult<> of such. Consuming file downloads ​ ​ There are a few conveniences for easily consuming downloaded files from your custom pages. VueKnockout Vue Knockout The API Callers have a property url. This can be provided directly to your HTML template, with the browser invoking the endpoint automatically. API Callers Alternatively, the API Callers for file-returning methods have a method getResultObjectUrl(vue). If the method was invoked programmatically (i.e. via caller(), caller.invoke(), or caller.invokeWithArgs()), this method returns an Object URL that can be set as the src of an image or video HTML tag. API Callers Object URL The TypeScript Method Objects for HTTP GET methods have a property url. This can be provided directly to your HTML, with the browser invoking the endpoint as normal. TypeScript Method Objects Alternatively, the TypeScript Method Objects for file-returning methods have a property resultObjectUrl. If the method is invoked programmatically (i.e. via .invoke() or .invokeWithArgs()), this property contains an Object URL that can be set as the src of an image or video HTML tag. TypeScript Method Objects Object URL Database-stored Files ​ ​ When storing large byte[] objects in your EF models, it is important that these are never loaded unless necessary. Loading these can cause significant garbage collector churn, or even bring your app to a halt. To achieve this with EF, you can either utilize Table Splitting, or you can use an entire dedicated table that only contains a primary key and the binary content, and nothing else. bring your app to a halt Table Splitting WARNING Storing large binary objects in relational databases comes with significant drawbacks. For large-volume cloud solutions, it is much more costly than dedicated cloud-native file storage like Azure Storage or S3. Also of note is that the larger a database is, the more difficult its backup process becomes. For files that are stored in your database, Coalesce supports a pattern that allows the file to be streamed directly to the HTTP response without needing to allocate a chunk of memory for the whole file at once. Simply pass an EF IQueryable<byte[]> to the constructor of IntelliTect.Coalesce.Models.File. This implementation, however, is specific to the underlying EF database provider. Currently, only SQL Server and SQLite are supported. Please open a Github issue to request support for other providers. An example of this mechanism is included in the DownloadAttachment method in the code sample below. The following is an example of utilizing Table Splitting for database-stored files. Generally speaking, metadata about the file should be stored on the "main" entity, and only the bytes of the content should be split into a separate entity. Other File Storage ​ ​ For any other storage mechanism, implementations are similar to the database storage approach above. However, instead of table splitting or using a whole separate table, the file contents are simply stored elsewhere. Continue storing metadata about the file on the primary entity, and implement upload/download methods as desired that wrap the storage provider. For downloads, prefer directly providing the underlying Stream to the IFile versus wrapping a byte[] in a MemoryStream. This will reduce server memory usage and garbage collector churn. For cloud storage providers where complex security logic is not needed, consider having clients consume the URL of the cloud resource directly rather than passing the file content through your own server. Previous page[TypeScriptPartial] Next pageData SourcesData Sources ​ ​ In Coalesce, all data that is retrieved from your database through the generated controllers is done so by a data source. These data sources control what data gets loaded and how it gets loaded. By default, there is a single generic data source that serves all data for your models in a generic way that fits many of the most common use cases - the Standard Data Source. Standard Data Source In addition to this standard data source, Coalesce allows you to create custom data sources that provide complete control over the way data is loaded and serialized for transfer to a requesting client. These data sources are defined on a per-model basis, and you can have as many of them as you like for each model. Defining Data Sources ​ ​ By default, each of your models that Coalesce exposes will expose the standard data source (IntelliTect.Coalesce.StandardDataSource<T, TContext>). This data source provides all the standard functionality one would expect - paging, sorting, searching, filtering, and so on. Each of these component pieces is implemented in one or more virtual methods, making the StandardDataSource a great place to start from when implementing your own data source. To suppress this behavior of always exposing the raw StandardDataSource, create your own custom data source and annotate it with [DefaultDataSource]. To implement your own custom data source, you simply need to define a class that implements IntelliTect.Coalesce.IDataSource<T>. To expose your data source to Coalesce, either place it as a nested class of the type T that you data source serves, or annotate it with the [Coalesce] attribute. Of course, the easiest way to create a data source that doesn't require you to re-engineer a great deal of logic would be to inherit from IntelliTect.Coalesce.StandardDataSource<T, TContext>, and then override only the parts that you need. The structure of the IQueryable built by the various methods of StandardDataSource is used to shape and trim the structure of the DTO as it is serialized and sent out to the client. One may also override method IncludeTree GetIncludeTree(IQueryable<Person> query, IDataSourceParameters parameters) to control this explicitly. See Include Tree for more information on how this works. Include Tree WARNING If you create a custom data source that has custom logic for securing your data, be aware that the default implementation of StandardDataSource (or your custom default implementation - see below) is still exposed unless you annotate one of your custom data sources with [DefaultDataSource]. Doing so will replace the default data source with the annotated class for your type T. Dependency Injection ​ ​ All data sources are instantiated using dependency injection and your application's IServiceProvider. As a result, you can add whatever constructor parameters you desire to your data sources as long as a value for them can be resolved from your application's services. The single parameter to the StandardDataSource is resolved in this way - the CrudContext<TContext> contains the common set of objects most commonly used, including the DbContext and the ClaimsPrincipal representing the current user. Consuming Data Sources ​ ​ VueKnockout Vue Knockout The ViewModels and ListViewModels each have a property called $dataSource. This property accepts an instance of a DataSource class generated in the Model Layer. ViewModels ListViewModels DataSource Model Layer The TypeScript ViewModels and TypeScript ListViewModels each have a property called dataSource. These properties accept an instance of a Coalesce.DataSource<T>. Generated classes that satisfy this relationship for all the data sources that were defined in C# may be found in the dataSources property on an instance of a ViewModel or ListViewModel, or in ListViewModels.<ModelName>DataSources TypeScript ViewModels TypeScript ListViewModels Standard Parameters ​ ​ All methods on IDataSource<T> take a parameter that contains all the client-specified parameters for things paging, searching, sorting, and filtering information. Almost all virtual methods on StandardDataSource are also passed the relevant set of parameters. Custom Parameters ​ ​ On any data source that you create, you may add additional properties annotated with [Coalesce] that will then be exposed as parameters to the client. These property parameters are currently restricted to primitives (numeric types, strings) and dates (DateTime, DateTimeOffset). Property parameter primitives may be expanded to allow for more types in the future. List Auto-loading ​ ​ You can setup TypeScript List ViewModels to automatically reload from the server when data source parameters change: TypeScript List ViewModels VueKnockout Vue Knockout To automatically reload a ListViewModel when data source parameters change, simply use the list's $useAutoLoad or $startAutoLoad function: ListViewModel The properties created on the TypeScript objects are observables so they may be bound to directly. In order to automatically reload a list when a data source parameter changes, you must explicitly subscribe to it: Standard Data Source ​ ​ The standard data sources, IntelliTect.Coalesce.StandardDataSource<T> and its EntityFramework-supporting sibling IntelliTect.Coalesce.StandardDataSource<T, TContext>, contain a significant number of properties and methods that can be utilized and/or overridden at your leisure. Default Loading Behavior ​ ​ When an object or list of objects is requested, the default behavior of the the StandardDataSource is to load all of the immediate relationships of the object (parent objects and child collections), as well as the far side of many-to-many relationships. This is performed in StandardDataSource.GetQuery(), so in order to suppress this behavior in a custom data source, don't build you query off of base.GetQuery(), but instead start directly from the DbSet for your entity when building your custom query. many-to-many Clients can suppress this per-request by setting includes = "none" on your TypeScript ViewModel or ListViewModel, but note this is not a security mechanism and should only be used to reduce payload size or improve response time. ViewModel ListViewModel On the server, you can suppress this behavior by placing [Read(NoAutoInclude = true)] on either an entire class (affecting all navigation properties of that type), or on specific navigation properties. When placed on a entity class that holds sensitive data, this can help ensure you don't accidentally leak records due to forgetting to customize the data sources of the types whose navigation properties reference your sensitive entity. Properties ​ ​ The following properties are available for use on the StandardDataSource any any derived instances. CrudContext<TContext> Context  The object passed to the constructor that contains the set of objects needed by the standard data source, and those that are most likely to be used in custom implementations. TContext Db  An instance of the DbContext that contains a DbSet<T> for the entity served by the data source. ClaimsPrincipal User  The user making the current request. int MaxSearchTerms  The max number of search terms to process when interpreting a search term word-by-word. Override by setting a value in the constructor. int DefaultPageSize  The page size to use if none is specified by the client. Override by setting a value in the constructor. int MaxPageSize  The maximum page size that will be served. By default, client-specified page sizes will be clamped to this value. Override by setting a value in the constructor. Method Overview ​ ​ The standard data source contains 19 different methods which can be overridden in your derived class to control its behavior. These methods often call one another, so overriding one method may cause some other method to no longer be called. The hierarchy of method calls, ignoring any logic or conditions contained within, is as follows: Method Details ​ ​ All of the methods outlined above can be overridden. A description of each of the non-interface inner methods is as follows: IQueryable<T> GetQuery(IDataSourceParameters parameters);
Task<IQueryable<T>> GetQueryAsync(IDataSourceParameters parameters);  The method is the one that you will most commonly be override in order to implement custom query logic. The default implementation of GetQueryAsync simply calls GetQuery - be aware of this in cases of complex overrides/inheritance. From this method, you could: Specify additional query filtering such as row-level security or soft-delete logic. Or, restrict the data source entirely for users or whole roles by returning an empty query.Include additional data using EF's .Include() and .ThenInclude().Add additional edges to the serialized object graph using Coalesce's .IncludedSeparately() and .ThenIncluded(). Specify additional query filtering such as row-level security or soft-delete logic. Or, restrict the data source entirely for users or whole roles by returning an empty query. Include additional data using EF's .Include() and .ThenInclude(). Add additional edges to the serialized object graph using Coalesce's .IncludedSeparately() and .ThenIncluded(). Note When GetQuery is overridden, the Default Loading Behavior is overridden as well. To restore this behavior, use the IQueryable<T>.IncludeChildren() extension method to build your query. Default Loading Behavior IncludeTree? GetIncludeTree(IQueryable<T> query, IDataSourceParameters parameters)  Allows for explicitly specifying the Include Tree that will be used when serializing results obtained from this data source into DTOs. By default, the query that is build up through all the other methods in the data source will be used to build the include tree. Include Tree bool CanEvalQueryAsynchronously(IQueryable<T> query)  Called by other methods in the standard data source to determine whether or not EF Core async methods will be used to evaluate queries. This may be globally disabled when bugs like https://github.com/dotnet/SqlClient/issues/593 are present in EF Core. https://github.com/dotnet/SqlClient/issues/593 IQueryable<T> ApplyListFiltering(IQueryable<T> query, IFilterParameters parameters)  A simple wrapper that calls ApplyListPropertyFilters and ApplyListSearchTerm. IQueryable<T> ApplyListPropertyFilters(IQueryable<T> query, IFilterParameters parameters)  For each value in parameters.Filter, invoke ApplyListPropertyFilter to apply a filter to the query. IQueryable<T> ApplyListPropertyFilter(IQueryable<T> query, PropertyViewModel prop, string value)  Given a property and a client-provided string value, perform some filtering on that property. Dates with a time component will be matched exactly.Dates with no time component will match any dates that fell on that day.Strings will match exactly unless an asterisk is found, in which case they will be matched with string.StartsWith.Enums will match by string or numeric value. Multiple comma-delimited values will create a filter that will match on any of the provided values.Numeric values will match exactly. Multiple comma-delimited values will create a filter that will match on any of the provided values. Dates with a time component will be matched exactly. Dates with no time component will match any dates that fell on that day. Strings will match exactly unless an asterisk is found, in which case they will be matched with string.StartsWith. Enums will match by string or numeric value. Multiple comma-delimited values will create a filter that will match on any of the provided values. Numeric values will match exactly. Multiple comma-delimited values will create a filter that will match on any of the provided values. IQueryable<T> ApplyListSearchTerm(IQueryable<T> query, IFilterParameters parameters)  Applies filters to the query based on the specified search term. See [Search] for a detailed look at how searching works in Coalesce. [Search] IQueryable<T> ApplyListSorting(IQueryable<T> query, IListParameters parameters)  If any client-specified sort orders are present, invokes ApplyListClientSpecifiedSorting. Otherwise, invokes ApplyListDefaultSorting. IQueryable<T> ApplyListClientSpecifiedSorting(IQueryable<T> query, IListParameters parameters)  Applies sorting to the query based on sort orders specified by the client. If the client specified "none" as the sort field, no sorting will take place. IQueryable<T> ApplyListDefaultSorting(IQueryable<T> query)  Applies default sorting behavior to the query, including behavior defined with use of [DefaultOrderBy] in C# POCOs, as well as fallback sorting to "Name" or primary key properties. IQueryable<T> ApplyListPaging(IQueryable<T> query, IListParameters parameters, int? totalCount, out int page, out int pageSize)  Applies paging to the query based on incoming parameters. Provides the actual page and pageSize that were used as out parameters. Task<int> GetListTotalCountAsync(IQueryable<T> query, IFilterParameters parameters)  Simple wrapper around invoking .Count() on a query. void TransformResults(IReadOnlyList<T> results, IDataSourceParameters parameters);
Task TransformResultsAsync(IReadOnlyList<T> results, IDataSourceParameters parameters);  Allows for transformation of a result set after the query has been evaluated. This will be called for both lists of items and for single items. This can be used for populating non-mapped properties on a model, or conditionally loading navigation properties using logic that depends upon the contents of each loaded record. This method is only called immediately before mapping to a DTO; it does not affect operations that don't involve mapping to a DTO - e.g. when loading the target of a /save operation or when loading the invocation target of an instance method. instance method See the Security page for an example on how to use TransformResults to apply filtered includes. Security apply filtered includes Do not use TransformResults to modify any database-mapped scalar properties, since such changes could be inadvertently persisted to the database. IList<TDto> TrimListFields<TDto>(IList<TDto> mappedResult, IListParameters parameters)  Performs trimming of the fields of the result set based on the parameters given to the data source. Can be overridden to forcibly disable this, override the behavior to always trim specific fields, or any other functionality desired. Globally Replacing the Standard Data Source ​ ​ You can, of course, create a custom base data source that all your custom implementations inherit from. But, what if you want to override the standard data source across your entire application, so that StandardDataSource<,> will never be instantiated? You can do that too! Simply create a class that implements IEntityFrameworkDataSource<,> (the StandardDataSource<,> already does - feel free to inherit from it), then register it at application startup like so: Your custom data source must have the same generic type parameters - <T, TContext>. Otherwise, the Microsoft.Extensions.DependencyInjection service provider won't know how to inject it. Previous pageMethods Next pageBehaviorsBehaviors ​ ​ In a CRUD system, creating, updating, and deleting are considered especially different from reading. In Coalesce, the dedicated classes that perform these operations are derivatives of a special interface known as the IBehaviors<T>. These are their stories. Coalesce separates out the parts of your API that read your data from the parts that mutate it. The read portion is performed by Data Sources, and the mutations are performed by behaviors. Like data sources, there exists a standard set of behaviors that Coalesce provides out-of-the-box that cover the most common use cases for creating, updating, and deleting objects in your data model. Data Sources Also like data sources, these functions can be easily overridden on a per-model basis, allowing complete control over the ways in which your data is mutated by the APIs that Coalesce generates. However, unlike data sources which can have as many implementations per model as you like, you can only have one set of behaviors. Defining Behaviors ​ ​ By default, each of your models that Coalesce exposes will utilize the standard behaviors (IntelliTect.Coalesce.StandardBehaviors<T, TContext>) for the out-of-the-box API endpoints that Coalesce provides. These behaviors provide a set of create, update, and delete methods for an EF Core DbContext, as well as a plethora of virtual methods that make the StandardBehaviors a great base class for your custom implementations. Unlike data sources which require an annotation to override the Coalesce-provided standard class, the simple presence of an explicitly declared set of behaviors will suppress the standard behaviors. Note When you define a set of custom behaviors, take note that these are only used by the standard set of API endpoints that Coalesce always provides. They will not be used to handle any mutations in any Methods you write for your models. Methods To create your own behaviors, you simply need to define a class that implements IntelliTect.Coalesce.IBehaviors<T>. To expose your behaviors to Coalesce, either place it as a nested class of the type T that your behaviors are for, or annotate it with the [Coalesce] attribute. Of course, the easiest way to create behaviors that doesn't require you to re-engineer a great deal of logic would be to inherit from IntelliTect.Coalesce.StandardBehaviors<T, TContext>, and then override only the parts that you need. Dependency Injection ​ ​ All behaviors are instantiated using dependency injection and your application's IServiceProvider. As a result, you can add whatever constructor parameters you desire to your behaviors as long as a value for them can be resolved from your application's services. The single parameter to the StandardBehaviors is resolved in this way - the CrudContext<TContext> contains the common set of objects most commonly used, including the DbContext and the ClaimsPrincipal representing the current user. Standard Behaviors ​ ​ The standard behaviors, IntelliTect.Coalesce.StandardBehaviors<T> and its EntityFramework-supporting sibling IntelliTect.Coalesce.StandardBehaviors<T, TContext>, contain a significant number of properties and methods that can be utilized and/or overridden at your leisure. Properties ​ ​ CrudContext<TContext> Context  The object passed to the constructor that contains the set of objects needed by the standard behaviors, and those that are most likely to be used in custom implementations. TContext Db  An instance of the db context that contains a DbSet<T> for the entity handled by the behaviors ClaimsPrincipal User  The user making the current request. IDataSource<T> OverrideFetchForUpdateDataSource  A data source that, if set, will override the data source that is used to retrieve the target of an update operation from the database. The incoming values will then be set on this retrieved object. Null by default; override by setting a value in the constructor. IDataSource<T> OverridePostSaveResultDataSource  A data source that, if set, will override the data source that is used to retrieve a newly-created or just-updated object from the database after a save. The retrieved object will be returned to the client. Null by default; override by setting a value in the constructor. IDataSource<T> OverrideFetchForDeleteDataSource  A data source that, if set, will override the data source that is used to retrieve the target of an delete operation from the database. The retrieved object will then be deleted. Null by default; override by setting a value in the constructor. IDataSource<T> OverridePostDeleteResultDataSource  A data source that, if set, will override the data source that is used to retrieve the target of an delete operation from the database after it has been deleted. If an object is able to be retrieved from this data source, it will be sent back to the client. This allows soft-deleted items to be returned to the client when the user is able to see them. Null by default; override by setting a value in the constructor. Method Overview ​ ​ The standard behaviors implementation contains many different methods which can be overridden in your derived class to control functionality. These methods often call one another, so overriding one method may cause some other method to no longer be called. The hierarchy of method calls, ignoring any logic or conditions contained within, is as follows: Method Details ​ ​ All of the methods outlined above can be overridden. A description of each of the methods is as follows: Task<ItemResult<TDto?>> SaveAsync<TDto>(TDto incomingDto, IDataSource<T> dataSource, IDataSourceParameters parameters)  Save the given item. This is the main entry point for saving, and takes a DTO as a parameter. This method is responsible for performing mapping to your EF models and ultimately saving to your database. If it is required that you access properties from the incoming DTO in this method, a set of extension methods GetValue and GetObject are available on the DTO for accessing properties that are mapped 1:1 with your EF models. Task<(SaveKind Kind, object? IncomingKey)> DetermineSaveKindAsync<TDto>(TDto incomingDto, IDataSource<T> dataSource, IDataSourceParameters parameters)  Given the incoming DTO on which Save has been called, examine its properties to determine if the operation is meant to be a create or an update operation. Return this distinction along with the key that was used to make the distinction. This method is called outside of the standard data source by the base API controller to perform role-based security on saves at the controller level. DbSet<T> GetDbSet()  Returns a DbSet<T> that items can be added to (creates) or remove from (deletes). ItemResult ValidateDto(SaveKind kind, IClassDto<T> dto)  Provides a chance to validate the properties of the DTO object itself, as opposed to doing validation in BeforeSave of the properties of the model after the DTO has been mapped to the model. This also where attribute-based validation is performed. attribute-based validation To perform custom validation in this method (uncommon), there are a number of extension methods on IClassDto<T> that can be used to access the value of the properties of Generated C# DTOs. For behaviors on Custom DTOs where the DTO type is known, simply cast to the correct type. Generated C# DTOs Custom DTOs T MapIncomingDto<TDto>(SaveKind kind, T? item, TDto dto, IDataSourceParameters parameters)  Map the properties of the incoming DTO to the model that will be saved to the database. For a SaveKind.Create, this will call the MapToNew method on the DTO and a new instance must be returned (item will be null). For a SaveKind.Update, this will call the MapTo method on the DTO, and the incoming item must be returned. If more precise control is needed, extension methods on IClassDto<T> or casting to a known type can be used to get specific values. If all else fails, the DTO can be reflected upon. Task<ItemResult> BeforeSaveAsync(SaveKind kind, T? oldItem, T item);
ItemResult BeforeSave(SaveKind kind, T? oldItem, T item)  Provides an easy way for derived classes to intercept a save attempt and either reject it by returning an unsuccessful result, or approve it by returning success. The incoming item can also be modified at will in this method to override changes that the client made as desired. ItemResult AfterSave(SaveKind kind, T? oldItem, ref T item, ref IncludeTree? includeTree)  Provides an easy way for derived classes to perform actions after a save operation has been completed. Failure results returned here will present an error to the client, but will not prevent modifications to the database since changes have already been saved at this point. This method can optionally modify or replace the item that is sent back to the client after a save by setting ref T item to another object or to null. Setting ref IncludeTree includeTree will override the Include Tree used to shape the response object. Include Tree WARNING Setting ref T item to null will prevent the new object from being returned - be aware that this can be harmful in create scenarios since it prevents the client from receiving the primary key of the newly created item. If autoSave is enabled on the client, this could cause a large number of duplicate objects to be created in the database, since each subsequent save by the client will be treated as a create when the incoming object lacks a primary key. Task<ItemResult<TDto?>> DeleteAsync<TDto>(object id, IDataSource<T> dataSource, IDataSourceParameters parameters)  Deletes the given item. Task<ItemResult> BeforeDeleteAsync(T item);
ItemResult BeforeDelete(T item)  Provides an easy way to intercept a delete request and potentially reject it (by returning a non-success ItemResult). Task ExecuteDeleteAsync(T item)  Performs the delete action against the database. The implementation of this method removes the item from its corresponding DbSet<T>, and then calls Db.SaveChangesAsync(). Overriding this allows for changing this row-deletion implementation to something else, like setting of a soft delete flag, or copying the data into another archival table before deleting. void AfterDelete(ref T item, ref IncludeTree? includeTree)  Allows for performing any sort of cleanup actions after a delete has completed. If the item was still able to be retrieved from the database after the delete operation completed, this method allows lets you modify or replace the item that is sent back to the client by setting ref T item to another object or to null. Setting ref IncludeTree includeTree will override the Include Tree used to shape the response object. Include Tree Globally Replacing the Standard Behaviors ​ ​ You can, of course, create a custom base behaviors class that all your custom implementations inherit from. But, what if you want to override the standard behaviors across your entire application, so that StandardBehaviors<,> will never be instantiated? You can do that too! Simply create a class that implements IEntityFrameworkBehaviors<,> (the StandardBehaviors<,> already does - feel free to inherit from it), then register it at application startup like so: Your custom behaviors class must have the same generic type parameters - <T, TContext>. Otherwise, the Microsoft.Extensions.DependencyInjection service provider won't know how to inject it. Previous pageData Sources Next pageFrontend - VueVue Overview ​ ​ The Vue stack for Coalesce has been designed from the ground up to be used to build modern web applications using current technologies like Vite, ES Modules, and more. It enables you to use all of the features of Vue.js, including building a SPA, and the ability to use modern component frameworks like Vuetify. Vuetify Getting Started ​ ​ Check out Getting Started with Vue to learn how to get a new Coalesce Vue project up and running. Getting Started with Vue TypeScript Layers ​ ​   The generated code for the Vue stack all builds on the coalesce-vue NPM package which contains most of the core functionality of the Vue stack. Its version should generally be kept in sync with the IntelliTect.Coalesce NuGet packages in your project. coalesce-vue IntelliTect.Coalesce NuGet packages Both the generated code and coalesce-vue are split into four layers, with each layer building on the layers underneath. From the bottom, these layers are: coalesce-vue Metadata Layer ​ Metadata Layer ​ The metadata layer, generated as metadata.g.ts, contains information about the types, properties, methods, and other components of your data model. Because Vue applications are typically compiled into a set of static assets, it is necessary for the frontend code to have a representation of your data model as an analog to the ReflectionRepository that is available at runtime in your .NET app. Read more about the Metadata layer Read more about the Metadata layer Model Layer ​ Model Layer ​ The model layer, generated as models.g.ts, contains a set of TypeScript interfaces that represent each client-exposed type in your data model. Each interface contains all the Properties of that type, as well as a $metadata property that references the metadata object for that type. Enums and Data Sources are also represented in the model layer. Properties metadata Data Sources Read more about the Model layer Read more about the Model layer API Client Layer ​ API Client Layer ​ The API client layer, generated as api-clients.g.ts, exports a class for each API controller that was generated for your data model. These classes are stateless and provide one method for each API endpoint. This includes both the standard set of endpoints created for Entity Models and Custom DTOs, as well as any custom Methods on the aforementioned types, as well as any methods on your Services. Entity Models Custom DTOs Methods Services Read more about the API Client layer Read more about the API Client layer ViewModel Layer ​ ViewModel Layer ​ The ViewModel layer, generated as viewmodels.g.ts, exports a ViewModel class for each API-backed type in your data model (Entity Models, Custom DTOs, and Services). It also exports a ListViewModel type for Entity Models and Custom DTOs. Entity Models Custom DTOs Services Entity Models Custom DTOs These classes provide a wide array of functionality that is useful when interacting with your data model through a user interface. The generated ViewModels are the primary way that Coalesce is used when developing a Vue application. Read more about the ViewModel layer Read more about the ViewModel layer Vue Components ​ ​    The Vue stack for Coalesce provides a set of components based on Vuetify, packaged up in an NPM package coalesce-vue-vuetify2 or coalesce-vue-vuetify3. These components are driven primarily by the Metadata Layer, and include both low level input and display components like c-input and c-display that are highly reusable in the custom pages you'll build in your application, as well as high-level components like c-admin-table-page and c-admin-editor-page that constitute entire pages. Vue a set of components Vuetify coalesce-vue-vuetify2 coalesce-vue-vuetify3 Metadata Layer c-input c-display c-admin-table-page c-admin-editor-page Read more about the Vuetify Components here. Read more about the Vuetify Components here Admin Views ​ ​ The Vue.js stack for Coalesce provides some high level components that provide functionality of whole pages like c-admin-table-page and c-admin-editor-page. c-admin-table-page c-admin-editor-page The template described in Getting Started with Vue comes with routes already in place for these page-level components. For example, /admin/Person for a table, /admin/Person/edit to create a new Person, and /admin/Person/edit/:id to edit a Person. Getting Started with Vue Previous pageBehaviors Next pageMetadataVue Metadata Layer ​ ​ The metadata layer, generated as metadata.g.ts, contains information about the types, properties, methods, and other components of your data model. Because Vue applications are typically compiled into a set of static assets, it is necessary for the frontend code to have a representation of your data model as an analog to the ReflectionRepository that is available at runtime in your .NET app. Concepts ​ ​ The following is a non-exhaustive list of the general concepts used by the metadata layer. The source code of coalesce-vue provides the most exhaustive set of documentation about the metadata layer: source code of coalesce-vue Metadata ​ ​ All objects in the metadata layer that represent any kind of metadata have, at the very least, a name, the name of the metadata element in code (type names, property names, parameter names, etc). and a displayName, the human-readable form of the name that is suitable for presentation when needed. Names follow the casing convention of their corresponding language elements - types are PascalCased, while other things like properties, methods, and parameters are camelCased. Type ​ ​ All custom types exposed by your application's data model will have a Type metadata object generated. This includes both C# classes, and C# enums. Class types include model (for Entity Models and Custom DTOs) and object (for External Types). Entity Models Custom DTOs External Types Value ​ ​ In the metadata layer, a Value is the usage of a type. This could be any type - strings, numbers, enums, classes, or even void. Values can be found in the collection of an object's properties, a method's parameters or return value, or as a data source's parameters. All values have the following properties: type: TypeDiscriminator  Type could be a language primitive like string or number, a non-primitive JavaScript type (date, file), or in the case of a custom Type, the type kind of that type (model, enum, object). For custom types, an additional property typeDef will refer to the Type metadata for that type. role: ValueRole  Role represents what purpose the value serves in a relational model. Either value (the default - no relational role), primaryKey, foreignKey, referenceNavigation, or collectionNavigation. Property ​ ​ A Property is a more refined Value that contains a number of additional fields based on the role of the property. Domain ​ ​ The type of the default export of the generated metadata. Serves as a single root from which all other metadata can be accessed. Contains fields types, enums, and services as organizing structures for the different kinds of custom types. Previous pageFrontend - Vue Next pageModelsVue Model Layer ​ ​ The model layer, generated as models.g.ts, contains a set of TypeScript interfaces that represent each client-exposed type in your data model. Each interface contains all the Properties of that type, as well as a $metadata property that references the metadata object for that type. Enums and Data Sources are also represented in the model layer. Properties metadata Data Sources The model layer also includes a TypeScript class for each type that can be used to easily instantiate a valid implementation of its corresponding interface. However, it is not necessary for the classes to be used, and all parts of Coalesce that interact with the model layer don't perform any instanceof checks against models - the $metadata property is used to determine type identity. Concepts ​ ​ The model layer is fairly simple - the only main concept it introduces on top of the Metadata Layer is the notion of interfaces and enums that mirror the C# types in your data model. As with the Metadata Layer, the source code of coalesce-vue is a great documentation supplement to this page. Metadata Layer Metadata Layer source code of coalesce-vue Model ​ ​ An interface describing an instance of a class type from your application's data model. All Model interfaces contain members for all the Properties of that type, as well as a $metadata property that references the metadata object for that type. Properties DataSource ​ ​ A class-based representation of a Data Source containing properties for any of the Custom Parameters of the data source, as well as a $metadata property that references the metadata object for the data source. Data Source Custom Parameters Data sources are generated as concrete classes in a namespace named DataSources that is nested inside a namespace named after their parent model type. For example: Model Functions ​ ​ The following functions exported from coalesce-vue can be used with your models: // Vue Options API
bindToQueryString(vue: Vue, obj: {}, key: string, queryKey: string = key, parse?: (v: any) => any, mode: 'push' | 'replace' = 'replace')
 
// Vue Composition API
useBindToQueryString(obj: {}, key: string, queryKey: string = key, parse?: (v: any) => any, mode: 'push' | 'replace' = 'replace')  Binds property key of obj to query string parameter queryKey. When the object's value changes, the query string will be updated using vue-router. When the query string changes, the object's value will be updated. vue-router The query string will be updated using either router.push or router.replace depending on the value of parameter mode. If the query string contains a value when this is called, the object will be updated with that value immediately. If the object being bound to has $metadata, information from that metadata will be used to serialize and parse values to and from the query string. Otherwise, String(value) will be used to serialize the value, and the parse parameter (if provided) will be used to parse the value from the query string. Options APIComposition API Options API Composition API // Vue Options API
bindKeyToRouteOnCreate(vue: Vue, model: Model<ModelType>, routeParamName: string = 'id', keepQuery: boolean = false)
 
// Vue Composition API
useBindKeyToRouteOnCreate(model: Model<ModelType>, routeParamName: string = 'id', keepQuery: boolean = false)  When model is created (i.e. its primary key becomes non-null), replace the current URL with one that includes uses primary key for the route parameter named by routeParamName. The query string will not be kept when the route is changed unless true is given to keepQuery. Options APIComposition API Options API Composition API Note The route will be replaced directly via the HTML5 History API such that vue-router will not observe the change as an actual route change, preventing the current view from being recreated if a path-based key is being used on the application's <router-view> component. HTML5 History API vue-router Advanced Model Functions ​ ​ The following functions exported from coalesce-vue can be used with your models. Note These functions are used to implement the higher-order layers in the Vue stack. higher-order layers While you're absolutely free to use them in your own code and can rely on their interface and behavior to remain consistent, you will find that you seldom need to use them directly - that's why we've split them into their own section here in the documentation. convertToModel(value: any, metadata: Value | ClassType): any  Given any JavaScript value value, convert it into a valid implementation of the value or type described by metadata. For metadata describing a primitive or primitive-like value, the input will be parsed into a valid implementation of the correct JavaScript type. For example, for metadata that describes a boolean, a string "true" will return a boolean true, and ISO 8601 date strings will result in a JavaScript Date object. For metadata describing a type, the input object will be mutated into a valid implementation of the appropriate model interface. Missing properties will be set to null, and any descendent properties of the provided object will be recursively processed with convertToModel. If any values are encountered that are fundamentally incompatible with the requested type described by the metadata, an error will be thrown. mapToModel(value: any, metadata: Value | ClassType): any  Performs the same operations as convertToModel, except that any objects encountered will not be mutated - instead, a new object or array will always be created. mapToDto(value: any, metadata: Value | ClassType): any  Maps the input to a representation suitable for JSON serialization. Will not serialize child objects or collections whose metadata includes dontSerialize. Will only recurse to a maximum depth of 3.   modelDisplay(model: Model, options?: DisplayOptions): string  Returns a string representing the model suitable for display in a user interface. Uses the displayProp defined on the object's metadata. If no displayProp is defined, the object will be displayed as JSON. The display prop on a model can be defined in C# with [ListText]. [ListText] See DisplayOptions for available options. DisplayOptions propDisplay(model: Model, prop: Property | string, options?: DisplayOptions): string  Returns a string representing the specified property of the given object suitable for display in a user interface. The property can either be a string, representing one of the model's properties, or the actual Property metadata object of the property. See DisplayOptions for available options. DisplayOptions valueDisplay(value: any, metadata: Value, options?: DisplayOptions): string  Returns a string representing the given value (described by the given metadata). See DisplayOptions for available options. DisplayOptions DisplayOptions ​ ​ The following options are available to functions in coalesce-vue that render a value or object for display: Note Dates rendered with the formatDistanceToNow function into a Vue component will not automatically be updated in realtime. If this is needed, you should use a strategy like using a key that you periodically update to force a re-render. key Time Zones ​ ​ In Coalesce Vue, all DateTimeOffset-based properties, for both inputs and display-only contexts, are by default formatted into the user's computer's system time zone. This is largely just a consequence of how the JavaScript Date type works. However, this behavior can be overridden by configuring a global default timezone, or by providing a time zone name to individual usages. Fields with a type of DateTime are agnostic to time zone and UTC offset and so are not subject to any of the following rules. setDefaultTimeZone(timeZoneName: string | null): void  Gets or sets the default time zone used by Coalesce. The time zone should be an IANA Time Zone Database name, e.g. "America/Los_Angeles". IANA Time Zone Database The time zone provided here is used in the following ways: It will be used as DisplayOptions.format.timeZone if no other value was provided for this option. This is used by functions modelDisplay, propDisplay, and valueDisplay, as well as the c-display component.It will be used by c-datetime-picker, used to both interpret the user input and display the selected date. This can also be set on individual component usages via the timeZone prop.It will be used when serializing DateTimeOffset fields into JSON DTOs, representing the ISO 8601 date string in the specified time zone rather than in the user's computer's system time zone. It will be used as DisplayOptions.format.timeZone if no other value was provided for this option. This is used by functions modelDisplay, propDisplay, and valueDisplay, as well as the c-display component. modelDisplay propDisplay valueDisplay c-display It will be used by c-datetime-picker, used to both interpret the user input and display the selected date. This can also be set on individual component usages via the timeZone prop. c-datetime-picker It will be used when serializing DateTimeOffset fields into JSON DTOs, representing the ISO 8601 date string in the specified time zone rather than in the user's computer's system time zone. getDefaultTimeZone(): string | null  Returns the current configured default time zone. Default is null, falling back on the user's computer's system time zone. Previous pageMetadata Next pageAPI ClientsVue API Client Layer ​ ​ The API client layer, generated as api-clients.g.ts, exports a class for each API controller that was generated for your data model. These classes are stateless and provide one method for each API endpoint. This includes both the standard set of endpoints created for Entity Models and Custom DTOs, as well as any custom Methods on the aforementioned types, as well as any methods on your Services. Entity Models Custom DTOs Methods Services The API clients provided by Coalesce are based on axios. All API clients used a shared axios instance, exported from coalesce-vue as AxiosClient. This instance can be used to configure all HTTP requests made by Coalesce, including things like attaching interceptors to modify the requests being made, or configuring defaults. axios interceptors defaults As with all the layers, the source code of coalesce-vue is also a great supplement to this documentation. source code of coalesce-vue Concepts ​ ​ API Client ​ ​ A class, generated for each controller-backed type in your data model as <ModelName>ApiClient and exported from api-clients.g.ts containing one method for each API endpoint. Each method on the API client takes in the regular parameters of the method as you would expect, as well as an optional AxiosRequestConfig parameter at the end that can be used to provide additional configuration for the single request, if needed. For the methods that correspond to the standard set of CRUD endpoints that Coalesce provides (get, list, count, save, delete), an additional parameter parameters is available that accepts the set of Standard Parameters appropriate for the endpoint. Standard Parameters Each method returns a Promise<AxiosResponse<TApiResult>> where TApiResult is either ItemResult, ItemResult<T>, or ListResult<T>, depending on the return type of the API endpoint. AxiosResponse is the response object from axios, containing the TApiResult in its data property, as well as other properties like headers. The returned type T is automatically converted into valid Model implementations for you. response object from axios Model implementations API Callers/API States ​ ​ A stateful function for invoking an API endpoint, created with the $makeCaller function on an API Client. API Callers provide a wide array of functionality that is useful for working with API endpoints that are utilized by a user interface. Because they are such an integral part of the overall picture of coalesce-vue, they have their own section below where they are explained in much greater detail. their own section below API Callers ​ ​ API Callers (typed with the name ApiState in coalesce-vue, sometimes also referred to as "loaders" or "invokers") are stateful functions for invoking an API endpoint, created with the $makeCaller function on an API Client. A summary of features: Endpoint Invocation ​ ​ Each API Caller is itself a function, so it can be invoked to trigger an API request to the server. State management ​ ​ API Callers contain properties about the last request made, including things like wasSuccessful, isLoading, result, and more. Concurrency Management ​ ​ Using setConcurrency(mode), you can configure how each individual caller handles what happens when multiple requests are made simultaneously Argument Binding ​ ​ API Callers can be created so that they have an args object that can be bound to, using .invokeWithArgs() to make a request using those arguments as the API endpoint's parameters. The API Callers created for the ViewModel Layer are all created this way. ViewModel Layer Creating and Invoking an API Caller ​ ​ API Callers can be created with the $makeCaller method of an API Client. The way in which it was created affects how it is invoked, as the parameters that the caller accepts are defined when it is created. TIP During typical development, it is unlikely that you'll need to make a custom API Caller - the ones created for you on the generated ViewModel Layer will usually suffice. However, creating your own can allow for some more advanced functionality. ViewModel Layer Some examples: A caller that takes no additional parameters: A caller that takes custom parameters: A caller that has an args object that can be bound to. This is how the generated API Callers in the ViewModel Layer are created: ViewModel Layer A caller that performs multiple async operations: The first parameter, resultType, can either be one of "item" or "list", indicating whether the method returns a ItemResult or ListResult (examples #1 and #3 above). It can also be a function which accepts the set of method metadata for the API Client and which returns the specific method metadata (example #2 above), or it can be a direct reference to a specific method metadata object. Properties ​ ​ The following state properties can be found on API Caller instances. These properties are useful for binding to in a user interface to display errors, results, or indicators of progress. All Callers ​ ​ isLoading: boolean  True if there is currently a request pending for the API Caller. wasSuccessful: boolean | null  A boolean indicating if the last request made was successful, or null if either no request has been made yet, or if a request has been made but has not yet completed. message: string | null  An error message from the last request, if any. Will be set to null upon successful completion of a request. hasResult: boolean  True if result is non-null. This prop is useful in performance-critical scenarios where checking result directly will cause an overabundance of re-renders in high-churn scenarios. args: {}  Holds an object for the arguments of the function, and will be used if the caller is invoked with its invokeWithArgs() method. Useful for binding the arguments of a caller to inputs in a user interface. Only exists if the caller was created with the option of being invoked with an args object as described in the sections above. get url(): string  Returns the URL for the method's HTTP endpoint. Any parameters are sourced from the args object. Useful for binding file-returning HTTP GET methods directly to image or video HTML elements. Only exists if the caller was created with the option of being invoked with an args object as described in the sections above. ItemResult-based Callers ​ ​ result: T | null  The principal data returned by the previous request. Will be set to null if the last response received returned no data (e.g. if the response was an error response) validationIssues: ValidationIssue[] | null  Any validation issues returned by the previous request. This is never populated automatically by Coalesce, and is therefore is only used if you have written custom code to populate it in your Behaviors or Methods. Behaviors Methods ListResult-based Callers ​ ​ result: Array<T> | null  The principal data returned by the previous request. Will be set to null if the last response received returned no data (e.g. if the response was an error response). page, pageSize, pageCount, totalCount: number | null  Properties which contain the pagination information returned by the previous request. Concurrency Mode ​ ​ setConcurrency(mode: 'disallow' | 'debounce' | 'cancel' | 'allow')  API callers have a setConcurrency method that allows you to customize how they behave when additional invocations are performed when there is already a request pending. There are four options available, with "disallow" being the default: "disallow" ​ ​ The default behavior - simply throws an error for any secondary invocations. Note Having "disallow" as the default prevents the unexpected behavior that can happen in a number of ways with the other modes: For requests that are performing data-mutating actions on the server, all other concurrency modes could lead to an unexpected end state of the data due to requests either being abandoned, cancelled, or potentially happening out-of-order.Throwing errors for multiple concurrent requests quickly surfaces issues during development where concurrent requests are not being correctly guarded against in a user interface - e.g. not disabling a "Save" or "Submit" button while the request is pending, which would otherwise lead to double-posts. For requests that are performing data-mutating actions on the server, all other concurrency modes could lead to an unexpected end state of the data due to requests either being abandoned, cancelled, or potentially happening out-of-order. Throwing errors for multiple concurrent requests quickly surfaces issues during development where concurrent requests are not being correctly guarded against in a user interface - e.g. not disabling a "Save" or "Submit" button while the request is pending, which would otherwise lead to double-posts. "debounce" ​ ​ When a secondary invocation is performed, enqueue it after the current pending invocation completes. If additional invocations are performed while there is already an invocation enqueued and waiting, the already-enqueued invocation is abandoned and replaced by the most recent invocation attempt. The promise of the abandoned invocation will be resolved with undefined (it is NOT rejected). "cancel" ​ ​ When a secondary invocation is performed, cancel the current pending invocation. This completely aborts the request, propagating all the way back to the server where cancellation can be observed with HttpContext.RequestAborted. The promise of the cancelled invocation will be resolved with undefined (it is NOT rejected). HttpContext.RequestAborted "allow" ​ ​ When a secondary invocation is performed, always continue normally, sending the request to the server. The state of the properties on the caller at any time will reflect the most recent response received from the server, which is never guaranteed to correlate with the most recent request made to the server - that is, requests are not guaranteed to complete in the order they were made. In particular, the isLoading property will be false after the first response comes back, even if the second response has not yet been received. WARNING For the reasons outlined above, it is generally not recommended to use "allow" unless you fully understand the drawbacks. This mode mirrors the legacy behavior of the Knockout stack for Coalesce. Response Caching ​ ​ Response caching on API Callers is a feature that will save API responses to persistent storage (sessionStorage or localStorage). The next time a matching request is made, the result property of the API Caller will be populated with that saved response, allowing for a faster time to interactivity and reduced repaints and shifting of elements as initial data loads after a page navigation. It does not prevent any HTTP requests from being made, and does not affect the Promise returned from invoke or invokeWithArgs. Common use cases include: Site-wide status or alert messagesServer-provided configurationDashboard data, like statistics or graphs Site-wide status or alert messages Server-provided configuration Dashboard data, like statistics or graphs When a cached response is loaded, result is populated with that response's data, wasSuccessful and hasResult are set to true, and onFulfilled callbacks are invoked. useResponseCaching(configuration?: ResponseCachingConfiguration | false)  Enables response caching on the API Caller. Only HTTP GET methods are supported, and file-returning methods are not supported. Call with false to disable caching after it was previously enabled. The available options are as follows: HTTP GET methods file-returning methods Other Methods ​ ​ API Callers have a few other methods available as well: cancel(): void  Manually cancel the current request. The promise of the cancelled invocation will be resolved with undefined (it is NOT rejected). If using concurrency mode "allow", only the most recent invocation is cancelled. onFulfilled((state: TInvoker) => void | Promise<any>): void  Add a callback to the caller to be invoked when a success response is received from the server. If a promise is returned, this promise will be awaited and will delay the setting of the isLoading prop to false until it completes. onRejected((state: TInvoker) => void | Promise<any>): void  Add a callback to the caller to be invoked when a failure response is received from the server. If a promise is returned, this promise will be awaited and will delay the setting of the isLoading prop to false until it completes. invoke(...args: TArgs)  The invoke function is a reference from the caller to itself. In other words, caller.invoke === caller. This exists to mirror the syntax of the Knockout generated method classes. invokeWithArgs(args?: {})  If called a parameter, that parameter will be used as the args object. Otherwise, caller.args will be used. Only exists if the caller was created with the option of being invoked with an args object as described in the sections above. getResultObjectUrl(vue?: Vue): string | undefined  If the method returns a file, this method will return an Object URL representing the value of the result prop. Object URL Accepts a Vue instance in order to manage the lifecycle of the URL, since object URLs must be manually released to avoid memory leaks. When the provided Vue component is destroyed, the object URL will be destroyed. If called inside the component template, the Vue instance can be acquired automatically. Only exists if the caller was created with the option of being invoked with an args object as described in the sections above. Previous pageModels Next pageView ModelsVue ViewModel Layer ​ ​ The ViewModel layer, generated as viewmodels.g.ts, exports a ViewModel class for each API-backed type in your data model (Entity Models, Custom DTOs, and Services). It also exports a ListViewModel type for Entity Models and Custom DTOs. Entity Models Custom DTOs Services Entity Models Custom DTOs These classes provide a wide array of functionality that is useful when interacting with your data model through a user interface. The generated ViewModels are the primary way that Coalesce is used when developing a Vue application. ViewModels ​ ​ The following members can be found on the generated Entity and Custom DTO ViewModels, exported from viewmodels.g.ts as <TypeName>ViewModel. Entity Custom DTO Model Data Properties ​ ​ Each ViewModel class implements the corresponding interface from the Model Layer, meaning that the ViewModel has a data property for each Property on the model. Object-typed properties will be typed as the corresponding generated ViewModel. Model Layer Property Changing the value of a property will automatically flag that property as dirty. See Auto-save & Dirty Flags below for information on how property dirty flags are used. Auto-save & Dirty Flags There are a few special behaviors when assigning to different kinds of data properties on View Models as well: Model Object Properties ​ ​ If the object being assigned to the property is not a ViewModel instance, a new instance will be created automatically and used instead of the incoming object.If the model property is a reference navigation, the corresponding foreign key property will automatically be set to the primary key of that object. If the incoming value was null, the foreign key will be set to null.If deep auto-saves are enabled on the instance being assigned to, auto-save will be spread to the incoming object, and to all other objects reachable from that object. If the object being assigned to the property is not a ViewModel instance, a new instance will be created automatically and used instead of the incoming object. If the model property is a reference navigation, the corresponding foreign key property will automatically be set to the primary key of that object. If the incoming value was null, the foreign key will be set to null. If deep auto-saves are enabled on the instance being assigned to, auto-save will be spread to the incoming object, and to all other objects reachable from that object. Model Collection Properties ​ ​ When assigning an entire array, any items in the array that are not a ViewModel instance will have an instance created for them.The same rule goes for pushing items into the existing array for a model collection - a new ViewModel instance will be created and be used instead of the object(s) being pushed. When assigning an entire array, any items in the array that are not a ViewModel instance will have an instance created for them. The same rule goes for pushing items into the existing array for a model collection - a new ViewModel instance will be created and be used instead of the object(s) being pushed. Foreign Key Properties ​ ​ If the corresponding navigation property contains an object, and that object's primary key doesn't match the new foreign key value being assigned, the navigation property will be set to null. Other Data Properties & Functions ​ ​ readonly $metadata: ModelType  The metadata object from the Metadata Layer layer for the type represented by the ViewModel. Metadata Layer readonly $stableId: number  An immutable number that is unique among all ViewModel instances, regardless of type. Useful for uniquely identifying instances with :key="vm.$stableId" in a Vue component, especially for instances that lack a primary key. $primaryKey: string | number  A getter/setter property that wraps the primary key of the model. Used to interact with the primary key of any ViewModel in a polymorphic way. $display(prop?: string | Property): string  Returns a string representation of the object, or one of its properties if specified, suitable for display. $addChild(prop: string | ModelCollectionNavigationProperty, initialDirtyData?: {})  Creates a new instance of an item for the specified child model collection, adds it to that collection, and returns the item. If initialDirtyData is provided, it will be loaded into the new instance with $loadDirtyData(). Loading & Parameters ​ ​ $load: ItemApiState;
$load(id?: TKey) => ItemResultPromise<TModel>;  An API Caller for the /get endpoint. Accepts an optional id argument - if not provided, the ViewModel's $primaryKey is used instead. Uses the instance's $params object for the Standard Parameters. API Caller Standard Parameters $params: DataSourceParameters  An object containing the Standard Parameters to be used for the $load, $save, $bulkSave, and $delete API callers. Standard Parameters $dataSource: DataSource  Getter/setter wrapper around $params.dataSource. Takes an instance of a Data Source class generated in the Model Layer. Data Source generated in the Model Layer $includes: string | null  Getter/setter wrapper around $params.includes. See Includes String for more information. Includes String $loadCleanData(source: {} | TModel, purgeUnsaved = false)  Loads data from the provided model into the current ViewModel, and then clears all dirty flags. Data is loaded recursively into all related ViewModel instances, preserving existing instances whose primary keys match the incoming data. If auto-save is enabled, only non-dirty properties are updated. This prevents user input that is pending a save from being overwritten by the response from an auto-save /save request. If purgeUnsaved is true, items without a primary key will be dropped from collection navigation properties. This is used by the $load caller in order to fully reset the object graph with the state from the server. $loadDirtyData(source: {} | TModel)  Same as $loadCleanData, but does not clear any existing dirty flags, nor does it clear any dirty flags that will be set while mutating the data properties of any ViewModel instance that gets loaded. constructor(initialDirtyData?: {} | TModel | null)  Create a new instance of the ViewModel, loading the given initial data with $loadDirtyData() if provided. Saving and Deleting ​ ​ $save: ItemApiState;
$save(overrideProps?: Partial<TModel>) => ItemResultPromise<TModel>;  An API Caller for the /save endpoint. Uses the instance's $params object for the Standard Parameters. A save operation saves only properties on the model it is called on - for deep/bulk saves, see $bulkSave. API Caller Standard Parameters $bulkSave This caller is used for both manually-triggered saves in custom code and for auto-saves. If the Rules/Validation report any errors when the caller is invoked, an error will be thrown. Rules/Validation overrideProps can provide properties to save that override the data properties on the ViewModel instance. This allows for manually saving a change to a property without setting the property on the ViewModel instance into a dirty state. This makes it easier to handle some scenarios where changing the value of the property may put the UI into a logically inconsistent state until the save response has been returned from the server - for example, if a change to one property affects the computed value of other properties. data properties When a save creates a new record and a new primary key is returned from the server, any entities attached to the current ViewModel via a collection navigation property will have their foreign keys set to the new primary key. This behavior, combined with the usage of deep auto-saves, allows for complex object graphs to be constructed even before any model in the graph has been created. When a save is in progress, the names of properties being saved are in contained in $savingProps. Saving behavior can be further customized with $loadResponseFromSaves and $saveMode, listed below. $delete: ItemApiState;
$delete() => ItemResultPromise<TModel>;  An API Caller for the /delete endpoint. Uses the instance's $params object for the Standard Parameters. API Caller Standard Parameters If the object was loaded as a child of a collection, it will be removed from that collection upon being deleted. Note that ViewModels currently only support tracking of a single parent collection, so if an object is programmatically added to additional collections, it will only be removed from one of them upon delete. $loadResponseFromSaves: boolean  Default true - controls if a ViewModel will be loaded with the data from the model returned by the /save endpoint when saved with the $save API caller. There is seldom any reason to disable this. $savingProps: ReadonlySet<string>  When $save.isLoading == true, contains the properties of the model currently being saved by $save (including auto-saves). Does not include non-dirty properties even if $saveMode == 'whole'. This can be used to make per-property UI state changes during saves - for example, displaying progress indicators on/near individual inputs, or disabling input controls. $saveMode: 'surgical' | 'whole'  Configures which properties of the model are sent to the server during a save or bulk save. "surgical" (default) By default, only dirty properties (and always the primary key) are sent to the server when performing a save. This improves the handling of concurrent changes being made by multiple users against different fields of the same entity at the same time - specifically, it prevents a user with a stale value of some field X from overwriting a more recent value of X in the database when the user is only making changes to some other property Y and has no intention of changing X. Save mode "surgical" doesn't help when multiple users are editing field X at the same time - if such a scenario is applicable to your application, you must implement more advanced handling of concurrency conflicts. more advanced handling of concurrency conflicts WARNING Surgical saves require DTOs on the server that are capable of determining which of their properties have been set by the model binder, as surgical saves are sent from the client by entirely omitting properties from the x-www-form-urlencoded body that is sent to the server. The Generated C# DTOs implement the necessary logic for this; however, any Custom DTOs must have this logic manually written by you, the developer. Either implement the same pattern that can be seen in the Generated C# DTOs, or do not use surgical saves with Custom DTOs. Generated C# DTOs Custom DTOs Generated C# DTOs "whole" All serializable properties of the object are sent back to the server with every save. $getPropDirty(propName: string): boolean  Returns true if the given property is flagged as dirty. $setPropDirty(propName: string, dirty: boolean = true, triggerAutoSave = true)  Manually set the dirty flag of the given property to the desired state. This seldom needs to be done explicitly, as mutating a property will automatically flag it as dirty. If dirty is true and triggerAutoSave is false, auto-save (if enabled) will not be immediately triggered for this specific flag change. Note that a future change to any other property's dirty flag will still trigger a save of all dirty properties. $isDirty: boolean  Getter/setter that summarizes the model's property-level dirty flags. Returns true if any properties are dirty. When set to false, all property dirty flags are cleared. When set to true, all properties are marked as dirty. Auto-save ​ ​ // Vue Options API
$startAutoSave(vue: Vue, options: AutoSaveOptions<this> = {})
 
// Vue Composition API
$useAutoSave(options: AutoSaveOptions<this> = {})  Starts auto-saving of the instance when its savable data properties become dirty. Saves are performed with the $save API Caller (documented above) and will not be performed if the ViewModel has any validation errors - see Rules/Validation below. API Caller Rules/Validation $stopAutoSave(): void  Turns off auto-saving of the instance. Does not recursively disable auto-saves on related instances if deep was used when auto-save was enabled. readonly $isAutoSaveEnabled: boolean  Returns true if auto-save is currently active on the instance. Bulk saves ​ ​ $bulkSave: ItemApiState;
$bulkSave(options: BulkSaveOptions) => ItemResultPromise<TModel>;  Bulk saves save all changes to an object graph in one API call and one database transaction. This includes creation, updates, and deletions of entities. To use bulk saves, you can work with your ViewModel instances on the client much in the same way you would on the server with Entity Framework. Assign objects to reference navigation properties and modify scalar values to perform creates and updates. To perform deletions, you must call model.$remove() on the ViewModel you want to remove, similar how you would call DbSet<>.Remove(model) on the server. If the client-side Rules/Validation report any errors for any of the models being saved in the operation, an error will be thrown. Rules/Validation On the server, each affected entity is handled through the same standard mechanisms as are used by individual saves or deletes (Behaviors, Data Sources, and Security Attributes), but with a bit of sugar on top: Behaviors Data Sources Security Attributes All operations are wrapped in a single database transaction that is rolled back if any individual operation fails.Foreign keys will be fixed up as new items are created, allowing a parent and child record to be created at the same time even when the client has no foreign key to link the two together. All operations are wrapped in a single database transaction that is rolled back if any individual operation fails. Foreign keys will be fixed up as new items are created, allowing a parent and child record to be created at the same time even when the client has no foreign key to link the two together. For the response to a bulk save, the server will load and return the root ViewModel that $bulkSave was called upon, using the instance's $params object for the Standard Parameters. Standard Parameters $remove(): void  Removes the item from its parent collection (if it is in a collection), and marks the item for deletion in the next bulk save. readonly $isRemoved: boolean  Returns true if the instance was previously removed by calling $remove(). Rules/Validation ​ ​ $addRule(prop: string | Property, identifier: string, rule: (val: any) => true | string)  Add a custom validation rule to the ViewModel for the specified property. identifier should be a short, unique slug that describes the rule; it is not displayed in the UI, but is used if you wish to later remove the rule with $removeRule(). The function you provide should take a single argument that contains the current value of the property, and should either return true to indicate that the validation rule has succeeded, or a string that will be displayed as an error message to the user. Any failing validation rules on a ViewModel will prevent that ViewModel's $save caller from being invoked. $removeRule(prop: string | Property, identifier: string)  Remove a validation rule from the ViewModel for the specified property and rule identifier. This can be used to remove either a rule that was provided by the generated Metadata Layer, or a custom rule that was added by $addRule. Reference your generated metadata file metadata.g.ts to see any generated rules and the identifiers they use. Metadata Layer $getRules(prop: string | Property): ((val: any) => string | true)[]  Returns an array of active rule functions for the specified property, or undefined if the property has no active validation rules. $getErrors(prop?: string | Property): Generator<string>  Returns a generator that provides all error messages for either a specific property (if provided) or the entire model (if no prop argument is provided). generator TIP You can obtain an array from a generator with Array.from(vm.$getErrors()) or [...vm.$getErrors()] readonly $hasError: boolean  Indicates if any properties have validation errors. Generated Members ​ ​ API Callers ​ ​ For each of the instance Methods of the type, an API Caller will be generated. Methods API Caller addTo*() Functions ​ ​ For each collection navigation property, a method is generated that will create a new instance of the ViewModel for the collected type, add it to the collection, and then return the new object. collection navigation property Many-to-many helper collections ​ ​ For each collection navigation property annotated with [ManyToMany], a getter-only property is generated that returns a collection of the object on the far side of the many-to-many relationship. Nulls are filtered from this collection. collection navigation property [ManyToMany] ListViewModels ​ ​ The following members can be found on the generated ListViewModels, exported from viewmodels.g.ts as *TypeName*ListViewModel. Data Properties ​ ​ readonly $items: T[]  Collection holding the results of the last successful invocation of the $load API Caller. API Caller Parameters & API Callers ​ ​ $params: ListParameters  An object containing the Standard Parameters to be used for the $load and $count API callers. Standard Parameters $dataSource: DataSource  Getter/setter wrapper around $params.dataSource. Takes an instance of a Data Source class generated in the Model Layer. Data Source generated in the Model Layer $includes: string | null  Getter/setter wrapper around $params.includes. See Includes String for more information. Includes String $load: ListApiState;
$load() => ListResultPromise<TModel>  An API Caller for the /list endpoint. Uses the instance's $params object for the Standard Parameters. API Caller Standard Parameters Results are available in the $items property. The result property of the $load API Caller contains the raw results and is not recommended for use in general development - $items should always be preferred. $count: ItemApiState;
$count() => ItemResultPromise<number>  An API Caller for the /count endpoint. Uses the instance's $params object for the Standard Parameters. API Caller Standard Parameters The result is available in $count.result - this API Caller does not interact with other properties on the ListViewModel like $pageSize or $pageCount. readonly $hasPreviousPage: boolean 
readonly $hasNextPage: boolean  Properties which indicate if $page can be decremented or incremented, respectively. $pageCount and $page are used to make this determination. $previousPage(): void 
$nextPage(): void  Methods that will decrement or increment $page, respectively. Each does nothing if there is no previous or next page as returned by $hasPreviousPage and $hasNextPage. $page: number  Getter/setter wrapper for $params.page. Controls the page that will be requested on the next invocation of $load. $pageSize: number  Getter/setter wrapper for $params.pageSize. Controls the page that will be requested on the next invocation of $load. readonly $pageCount: number  Shorthand for $load.pageCount - returns the page count reported by the last successful invocation of $load. Auto-Load ​ ​ // Vue Options API
$startAutoLoad(vue: Vue, options: AutoLoadOptions<this> = {})
 
// Vue Composition API
$useAutoLoad(options: AutoLoadOptions<this> = {})  Starts auto-loading of the list as changes to its parameters occur. Loads are performed with the $load API Caller. API Caller $stopAutoLoad()  Manually turns off auto-loading of the instance. Auto-save ​ ​ // Vue Options API
$startAutoSave(vue: Vue, options: AutoSaveOptions<this> = {})
 
// Vue Composition API
$useAutoSave(options: AutoSaveOptions<this> = {})  Enables auto-save for the items in the list, propagating to new items as they're added or loaded. See ViewModel auto-save documentation for more details. ViewModel auto-save documentation $stopAutoSave(): void  Turns off auto-saving of the items in the list, and turns of propagation of auto-save to any future items if auto-save was previously turned on for the list. Only affects items that are currently in the list's $items. readonly $isAutoSaveEnabled: boolean  Returns true if auto-save is currently active on the instance. Generated Members ​ ​ API Callers ​ ​ For each of the static Methods on the type, an API Caller will be created. Methods API Caller Service ViewModels ​ ​ The following members can be found on the generated Service ViewModels, exported from viewmodels.g.ts as <ServiceName>ViewModel. Generated Members ​ ​ API Callers ​ ​ For each method of the Service, an API Caller will be created. Service API Caller Previous pageAPI Clients Next pageVuetify ComponentsVuetify Components ​ ​    The Vue stack for Coalesce provides a set of components based on Vuetify, packaged up in an NPM package coalesce-vue-vuetify2 or coalesce-vue-vuetify3. These components are driven primarily by the Metadata Layer, and include both low level input and display components like c-input and c-display that are highly reusable in the custom pages you'll build in your application, as well as high-level components like c-admin-table-page and c-admin-editor-page that constitute entire pages. Vue a set of components Vuetify coalesce-vue-vuetify2 coalesce-vue-vuetify3 Metadata Layer c-input c-display c-admin-table-page c-admin-editor-page Setup ​ ​ All Coalesce projects should be started from the template described in Getting Started with Vue, and will therefore have all the setup completed for you. Getting Started with Vue If for whatever reason you find yourself adding Coalesce to an existing project, use the template as a reference for what configuration needs to be added to your project. Display Components ​ ​ ComponentDescriptionc-displayA general-purpose component for displaying any Value by rendering the value to a string with the display functions from the Models Layer. For plain string and number values, usage of this component is largely superfluous. For all other value types including dates, booleans, enums, objects, and collections, it is very handy.c-loader-statusA component for displaying progress and error information for one or more API Callers.TIPIt is highly recommended that all API Callers utilized by your application that don't have any other kind of error handling should be represented by a c-loader-status so that users can be aware of any errors that occur.c-list-range-displayDisplays pagination information about the current $items of a ListViewModel in the format <start index> - <end index> of <total count>.c-tableA table component for displaying the contents of a ListViewModel. Also supports modifying the list's sort parameters by clicking on column headers. Pairs well with a c-list-pagination. ComponentDescription c-displayA general-purpose component for displaying any Value by rendering the value to a string with the display functions from the Models Layer. For plain string and number values, usage of this component is largely superfluous. For all other value types including dates, booleans, enums, objects, and collections, it is very handy. c-display c-display c-display A general-purpose component for displaying any Value by rendering the value to a string with the display functions from the Models Layer. For plain string and number values, usage of this component is largely superfluous. For all other value types including dates, booleans, enums, objects, and collections, it is very handy. A general-purpose component for displaying any Value by rendering the value to a string with the display functions from the Models Layer. For plain string and number values, usage of this component is largely superfluous. For all other value types including dates, booleans, enums, objects, and collections, it is very handy. Value display functions from the Models Layer values c-loader-statusA component for displaying progress and error information for one or more API Callers.TIPIt is highly recommended that all API Callers utilized by your application that don't have any other kind of error handling should be represented by a c-loader-status so that users can be aware of any errors that occur. c-loader-status c-loader-status c-loader-status A component for displaying progress and error information for one or more API Callers.TIPIt is highly recommended that all API Callers utilized by your application that don't have any other kind of error handling should be represented by a c-loader-status so that users can be aware of any errors that occur. A component for displaying progress and error information for one or more API Callers. API Callers TIP It is highly recommended that all API Callers utilized by your application that don't have any other kind of error handling should be represented by a c-loader-status so that users can be aware of any errors that occur. API Callers c-loader-status c-list-range-displayDisplays pagination information about the current $items of a ListViewModel in the format <start index> - <end index> of <total count>. c-list-range-display c-list-range-display c-list-range-display Displays pagination information about the current $items of a ListViewModel in the format <start index> - <end index> of <total count>. Displays pagination information about the current $items of a ListViewModel in the format <start index> - <end index> of <total count>. ListViewModel c-tableA table component for displaying the contents of a ListViewModel. Also supports modifying the list's sort parameters by clicking on column headers. Pairs well with a c-list-pagination. c-table c-table c-table A table component for displaying the contents of a ListViewModel. Also supports modifying the list's sort parameters by clicking on column headers. Pairs well with a c-list-pagination. A table component for displaying the contents of a ListViewModel. Also supports modifying the list's sort parameters by clicking on column headers. Pairs well with a c-list-pagination. ListViewModel sort parameters c-list-pagination Input Components ​ ​ ComponentDescriptionc-inputA general-purpose input component for most Values. c-input delegates to other components based on the type of value it is bound to. This includes both other Coalesce Vuetify Components as well as direct usages of some Vuetify components.c-selectA dropdown component that allows for selecting values fetched from the generated /list API endpoints.Used for selecting values for foreign key and navigation properties, or for selecting arbitrary objects or primary keys without a parent or owning object.c-datetime-pickerA general, all-purpose date/time input component that can be used either with models and metadata or as a standalone component using only v-model.c-select-many-to-manyA multi-select dropdown component that allows for selecting values fetched from the generated /list API endpoints for collection navigation properties that were annotated with [ManyToMany].c-select-string-valueA dropdown component that will present a list of suggested string values from a custom API endpoint. Allows users to input values that aren't provided by the endpoint.Effectively, this is a server-driven autocomplete list.c-select-valuesA multi-select input component for collections of non-object values (primarily strings and numbers).c-list-filtersA component that provides an interface for modifying the filters prop of a ListViewModel's parameters.c-list-paginationA component that provides an interface for modifying the pagination parameters of a ListViewModel.This is a composite of c-list-page-size, c-list-range-display, and c-list-page, arranged horizontally. It is designed to be used above or below a table (e.g. c-table).c-list-page-sizeA component that provides an dropdown for modifying the pageSize parameter prop of a ListViewModel.c-list-pageA component that provides previous/next buttons and a text field for modifying the page parameter prop of a ListViewModel. ComponentDescription c-inputA general-purpose input component for most Values. c-input delegates to other components based on the type of value it is bound to. This includes both other Coalesce Vuetify Components as well as direct usages of some Vuetify components. c-input c-input c-input A general-purpose input component for most Values. c-input delegates to other components based on the type of value it is bound to. This includes both other Coalesce Vuetify Components as well as direct usages of some Vuetify components. A general-purpose input component for most Values. c-input delegates to other components based on the type of value it is bound to. This includes both other Coalesce Vuetify Components as well as direct usages of some Vuetify components. Values Coalesce Vuetify Components Vuetify c-selectA dropdown component that allows for selecting values fetched from the generated /list API endpoints.Used for selecting values for foreign key and navigation properties, or for selecting arbitrary objects or primary keys without a parent or owning object. c-select c-select c-select A dropdown component that allows for selecting values fetched from the generated /list API endpoints.Used for selecting values for foreign key and navigation properties, or for selecting arbitrary objects or primary keys without a parent or owning object. A dropdown component that allows for selecting values fetched from the generated /list API endpoints. Used for selecting values for foreign key and navigation properties, or for selecting arbitrary objects or primary keys without a parent or owning object. c-datetime-pickerA general, all-purpose date/time input component that can be used either with models and metadata or as a standalone component using only v-model. c-datetime-picker c-datetime-picker c-datetime-picker A general, all-purpose date/time input component that can be used either with models and metadata or as a standalone component using only v-model. A general, all-purpose date/time input component that can be used either with models and metadata or as a standalone component using only v-model. models metadata c-select-many-to-manyA multi-select dropdown component that allows for selecting values fetched from the generated /list API endpoints for collection navigation properties that were annotated with [ManyToMany]. c-select-many-to-many c-select-many-to-many c-select-many-to-many A multi-select dropdown component that allows for selecting values fetched from the generated /list API endpoints for collection navigation properties that were annotated with [ManyToMany]. A multi-select dropdown component that allows for selecting values fetched from the generated /list API endpoints for collection navigation properties that were annotated with [ManyToMany]. [ManyToMany] c-select-string-valueA dropdown component that will present a list of suggested string values from a custom API endpoint. Allows users to input values that aren't provided by the endpoint.Effectively, this is a server-driven autocomplete list. c-select-string-value c-select-string-value c-select-string-value A dropdown component that will present a list of suggested string values from a custom API endpoint. Allows users to input values that aren't provided by the endpoint.Effectively, this is a server-driven autocomplete list. A dropdown component that will present a list of suggested string values from a custom API endpoint. Allows users to input values that aren't provided by the endpoint. Effectively, this is a server-driven autocomplete list. c-select-valuesA multi-select input component for collections of non-object values (primarily strings and numbers). c-select-values c-select-values c-select-values A multi-select input component for collections of non-object values (primarily strings and numbers). A multi-select input component for collections of non-object values (primarily strings and numbers). c-list-filtersA component that provides an interface for modifying the filters prop of a ListViewModel's parameters. c-list-filters c-list-filters c-list-filters A component that provides an interface for modifying the filters prop of a ListViewModel's parameters. A component that provides an interface for modifying the filters prop of a ListViewModel's parameters. ListViewModel parameters c-list-paginationA component that provides an interface for modifying the pagination parameters of a ListViewModel.This is a composite of c-list-page-size, c-list-range-display, and c-list-page, arranged horizontally. It is designed to be used above or below a table (e.g. c-table). c-list-pagination c-list-pagination c-list-pagination A component that provides an interface for modifying the pagination parameters of a ListViewModel.This is a composite of c-list-page-size, c-list-range-display, and c-list-page, arranged horizontally. It is designed to be used above or below a table (e.g. c-table). A component that provides an interface for modifying the pagination parameters of a ListViewModel. parameters ListViewModel This is a composite of c-list-page-size, c-list-range-display, and c-list-page, arranged horizontally. It is designed to be used above or below a table (e.g. c-table). c-list-page-size c-list-range-display c-list-page c-table c-list-page-sizeA component that provides an dropdown for modifying the pageSize parameter prop of a ListViewModel. c-list-page-size c-list-page-size c-list-page-size A component that provides an dropdown for modifying the pageSize parameter prop of a ListViewModel. A component that provides an dropdown for modifying the pageSize parameter prop of a ListViewModel. parameter ListViewModel c-list-pageA component that provides previous/next buttons and a text field for modifying the page parameter prop of a ListViewModel. c-list-page c-list-page c-list-page A component that provides previous/next buttons and a text field for modifying the page parameter prop of a ListViewModel. A component that provides previous/next buttons and a text field for modifying the page parameter prop of a ListViewModel. parameter ListViewModel Admin Components ​ ​ ComponentDescriptionc-admin-methodProvides an interface for invoking a method and rendering its result, designed to be use in an admin page.c-admin-methodsRenders in a Vuetify v-expansion-panels a c-admin-method for each method on a ViewModel or ListViewModel.c-admin-displayBehaves the same as c-display, except any collection navigation properties will be rendered as links to an admin list page, and any models will be rendered as a link to an admin item page.c-admin-editorAn editor for a single ViewModel instance. Provides a c-input for each property of the model.c-admin-editor-pageA page for a creating/editing single ViewModel instance. Provides a c-admin-editor and a c-admin-methods for the instance. Designed to be routed to directly with vue-router.c-admin-tableAn full-featured table for a ListViewModel, including a c-admin-table-toolbar, c-table, and c-list-pagination.c-admin-table-toolbarA full-featured toolbar for a ListViewModel designed to be used on an admin page, including "Create" and "Reload" buttons, a c-list-range-display, a c-list-page, a search field, c-list-filters, and a c-list-page-size.c-admin-table-pageA full-featured page for interacting with a ListViewModel. Provides a c-admin-table and a c-admin-methods for the list. Designed to be routed to directly with vue-router.c-admin-audit-log-pageA full-featured page for interacting with Coalesce's Audit Logging. Presents a view similar to c-admin-table-page with content optimized for viewing audit log records. Designed to be routed to directly with vue-router. ComponentDescription c-admin-methodProvides an interface for invoking a method and rendering its result, designed to be use in an admin page. c-admin-method c-admin-method c-admin-method Provides an interface for invoking a method and rendering its result, designed to be use in an admin page. Provides an interface for invoking a method and rendering its result, designed to be use in an admin page. method c-admin-methodsRenders in a Vuetify v-expansion-panels a c-admin-method for each method on a ViewModel or ListViewModel. c-admin-methods c-admin-methods c-admin-methods Renders in a Vuetify v-expansion-panels a c-admin-method for each method on a ViewModel or ListViewModel. Renders in a Vuetify v-expansion-panels a c-admin-method for each method on a ViewModel or ListViewModel. Vuetify v-expansion-panels c-admin-method ViewModel ListViewModel c-admin-displayBehaves the same as c-display, except any collection navigation properties will be rendered as links to an admin list page, and any models will be rendered as a link to an admin item page. c-admin-display c-admin-display c-admin-display Behaves the same as c-display, except any collection navigation properties will be rendered as links to an admin list page, and any models will be rendered as a link to an admin item page. Behaves the same as c-display, except any collection navigation properties will be rendered as links to an admin list page, and any models will be rendered as a link to an admin item page. c-display c-admin-editorAn editor for a single ViewModel instance. Provides a c-input for each property of the model. c-admin-editor c-admin-editor c-admin-editor An editor for a single ViewModel instance. Provides a c-input for each property of the model. An editor for a single ViewModel instance. Provides a c-input for each property of the model. ViewModel c-input c-admin-editor-pageA page for a creating/editing single ViewModel instance. Provides a c-admin-editor and a c-admin-methods for the instance. Designed to be routed to directly with vue-router. c-admin-editor-page c-admin-editor-page c-admin-editor-page A page for a creating/editing single ViewModel instance. Provides a c-admin-editor and a c-admin-methods for the instance. Designed to be routed to directly with vue-router. A page for a creating/editing single ViewModel instance. Provides a c-admin-editor and a c-admin-methods for the instance. Designed to be routed to directly with vue-router. ViewModel c-admin-editor c-admin-methods vue-router c-admin-tableAn full-featured table for a ListViewModel, including a c-admin-table-toolbar, c-table, and c-list-pagination. c-admin-table c-admin-table c-admin-table An full-featured table for a ListViewModel, including a c-admin-table-toolbar, c-table, and c-list-pagination. An full-featured table for a ListViewModel, including a c-admin-table-toolbar, c-table, and c-list-pagination. ListViewModel c-admin-table-toolbar c-table c-list-pagination c-admin-table-toolbarA full-featured toolbar for a ListViewModel designed to be used on an admin page, including "Create" and "Reload" buttons, a c-list-range-display, a c-list-page, a search field, c-list-filters, and a c-list-page-size. c-admin-table-toolbar c-admin-table-toolbar c-admin-table-toolbar A full-featured toolbar for a ListViewModel designed to be used on an admin page, including "Create" and "Reload" buttons, a c-list-range-display, a c-list-page, a search field, c-list-filters, and a c-list-page-size. A full-featured toolbar for a ListViewModel designed to be used on an admin page, including "Create" and "Reload" buttons, a c-list-range-display, a c-list-page, a search field, c-list-filters, and a c-list-page-size. ListViewModel c-list-range-display c-list-page c-list-filters c-list-page-size c-admin-table-pageA full-featured page for interacting with a ListViewModel. Provides a c-admin-table and a c-admin-methods for the list. Designed to be routed to directly with vue-router. c-admin-table-page c-admin-table-page c-admin-table-page A full-featured page for interacting with a ListViewModel. Provides a c-admin-table and a c-admin-methods for the list. Designed to be routed to directly with vue-router. A full-featured page for interacting with a ListViewModel. Provides a c-admin-table and a c-admin-methods for the list. Designed to be routed to directly with vue-router. ListViewModel c-admin-table c-admin-methods vue-router c-admin-audit-log-pageA full-featured page for interacting with Coalesce's Audit Logging. Presents a view similar to c-admin-table-page with content optimized for viewing audit log records. Designed to be routed to directly with vue-router. c-admin-audit-log-page c-admin-audit-log-page c-admin-audit-log-page A full-featured page for interacting with Coalesce's Audit Logging. Presents a view similar to c-admin-table-page with content optimized for viewing audit log records. Designed to be routed to directly with vue-router. A full-featured page for interacting with Coalesce's Audit Logging. Presents a view similar to c-admin-table-page with content optimized for viewing audit log records. Designed to be routed to directly with vue-router. Audit Logging c-admin-table-page vue-router Previous pageView Models Next pagec-displayc-display ​ ​ A general-purpose component for displaying any Value by rendering the value to a string with the display functions from the Models Layer. For plain string and number values, usage of this component is largely superfluous. For all other value types including dates, booleans, enums, objects, and collections, it is very handy. Value display functions from the Models Layer values Examples ​ ​ Typical usage, providing an object and a property on that object: Customizing date formatting (view format patterns): view format patterns A contrived example of using c-display to render the result of an API Caller: API Caller Displaying a standalone date value without a model or other source of metadata: Props ​ ​ for: string | Property | Value  A metadata specifier for the value being bound. Either a direct reference to the metadata object, or a string with the name of the value belonging to model, or a string in dot-notation that starts with a type name. model?: Model | DataSource  An object owning the value that was specified by the for prop. format: DisplayOptions["format"]  Shorthand for :options="{ format: format }", allowing for specification of the format to be used when displaying dates. See DisplayOptions for details on the options available for format. DisplayOptions options: DisplayOptions  Specify options for formatting some kinds of values, including dates. See DisplayOptions for details. DisplayOptions value: any // Vue 2
modelValue: any // Vue 3  Can be provided the value to be displayed in conjunction with the for prop, as an alternative to the model prop. This is an uncommon scenario - it is generally easier to use the for/model props together. Slots ​ ​ default - Used to display fallback content if the value being displayed is either null or "" (empty string). [DataTypeAttribute] ​ ​ For properties and other values annotated with [DataTypeAttribute], the following special handling occurs based on the data type: DataType.MultilineText: Renders with white-space: pre-wrap.DataType.Password: Renders with a show/hide toggle (hidden by default), showing a fixed number of dot characters when hidden.DataType.Url: Renders as a clickable link.DataType.EmailAddress: Renders as a clickable mailto link.DataType.PhoneNumber: Renders as a clickable tel link.DataType.ImageUrl: Renders as an img element."Color": Renders a colored dot next to the value, interpreting the field value as a 7-character HTML hex color code. DataType.MultilineText: Renders with white-space: pre-wrap. DataType.Password: Renders with a show/hide toggle (hidden by default), showing a fixed number of dot characters when hidden. DataType.Url: Renders as a clickable link. DataType.EmailAddress: Renders as a clickable mailto link. DataType.PhoneNumber: Renders as a clickable tel link. DataType.ImageUrl: Renders as an img element. "Color": Renders a colored dot next to the value, interpreting the field value as a 7-character HTML hex color code. Previous pageVuetify Components Next pagec-list-range-displayc-list-range-display ​ ​ Displays pagination information about the current $items of a ListViewModel in the format <start index> - <end index> of <total count>. ListViewModel Uses the pagination information returned from the last successful $load call, not the current $params of the ListViewModel. ListViewModel Examples ​ ​ Props ​ ​ list: ListViewModel  The ListViewModel to display pagination information for. ListViewModel Previous pagec-display Next pagec-loader-statusc-loader-status ​ ​ A component for displaying progress and error information for one or more API Callers. API Callers TIP It is highly recommended that all API Callers utilized by your application that don't have any other kind of error handling should be represented by a c-loader-status so that users can be aware of any errors that occur. API Callers c-loader-status Progress is indicated with a Vuetify v-progress-linear component, and errors are displayed in a v-alert. Transitions are applied to smoothly fade between the different states the the caller can be in. Vuetify v-progress-linear v-alert Transitions Examples ​ ​ Wrap contents of a details/edit page: Use c-loader-status to render a progress bar and any error messages, but don't use it to control content: Wrap a save/submit button: Hides the table before the first load has completed, or if loading the list encountered an error. Don't show the progress bar after we've already loaded the list for the first time (useful for loads that occur without user interaction, e.g. setInterval): Props ​ ​ loaders: 
  // Flags per component:
  | ApiCaller 
  | ApiCaller[]
  // Flags per caller:
  | { [flags: string]: ApiCaller | ApiCaller[] }   This prop has multiple options that support simple or complex usage scenarios: Flags Per Component ​ ​ A single instance, or array of API Callers, whose status will be represented by the component. The flags for these objects will be determined from the component-level flag props. API Callers flags flag props Flags Per Caller ​ ​ A more advanced usage allows passing different flags for different callers. Provide a dictionary object with entries mapping zero or more flags to one or more API Callers. Multiple entries of flags/caller pairs may be specified in the dictionary to give different behavior to different API callers. These flags are layered on top of the base flag props. flags API Callers flag props progressPlaceholder: boolean = true  Specify if space should be reserved for the progress indicator. If set to false, the content in the default slot may jump up and down slightly as the progress indicator shows and hides. progressAbsolute: boolean = false  Positions the progress bar absolutely. This can be useful in compact interfaces where extra space for the progress bar is undesirable, allowing the progress bar to potentially overlap content while active. height: number = 10  Specifies the height in pixels of the v-progress-linear used to indicate progress. v-progress-linear 
no-loading-content?: boolean;
no-error-content?: boolean;
no-initial-content?: boolean;
no-progress?: boolean;
no-initial-progress?: boolean;
no-secondary-progress?: boolean;  Component level flags options that control behavior when the simple form of loaders (single instance or array) is used, as well as provide baseline defaults that can be overridden by the advanced form of loaders (object map) . flags Flags ​ ​ The available flags are as follows, all of which default to true. In the object literal syntax for loaders, the no- prefix may be omitted to set the flag to true. FlagDescriptionno-loading-contentControls whether the default slot is rendered while any API caller is loading (i.e. when caller.isLoading === true).no-error-contentControls whether the default slot is rendered while any API Caller is in an error state (i.e. when caller.wasSuccessful === false).no-initial-contentControls whether the default slot is rendered while any API Caller has yet to receive a response for the first time (i.e. when caller.wasSuccessful === null).no-progressMaster toggle for whether the progress indicator is shown in any scenario.no-initial-progressControls whether the progress indicator is shown when an API Caller is loading for the very first time (i.e. when caller.wasSuccessful === null).no-secondary-progressControls whether the progress indicator is shown when an API Caller is loading any time after its first invocation (i.e. when caller.wasSuccessful !== null). FlagDescription no-loading-contentControls whether the default slot is rendered while any API caller is loading (i.e. when caller.isLoading === true). no-loading-content Controls whether the default slot is rendered while any API caller is loading (i.e. when caller.isLoading === true). no-error-contentControls whether the default slot is rendered while any API Caller is in an error state (i.e. when caller.wasSuccessful === false). no-error-content Controls whether the default slot is rendered while any API Caller is in an error state (i.e. when caller.wasSuccessful === false). no-initial-contentControls whether the default slot is rendered while any API Caller has yet to receive a response for the first time (i.e. when caller.wasSuccessful === null). no-initial-content Controls whether the default slot is rendered while any API Caller has yet to receive a response for the first time (i.e. when caller.wasSuccessful === null). no-progressMaster toggle for whether the progress indicator is shown in any scenario. no-progress Master toggle for whether the progress indicator is shown in any scenario. no-initial-progressControls whether the progress indicator is shown when an API Caller is loading for the very first time (i.e. when caller.wasSuccessful === null). no-initial-progress Controls whether the progress indicator is shown when an API Caller is loading for the very first time (i.e. when caller.wasSuccessful === null). no-secondary-progressControls whether the progress indicator is shown when an API Caller is loading any time after its first invocation (i.e. when caller.wasSuccessful !== null). no-secondary-progress Controls whether the progress indicator is shown when an API Caller is loading any time after its first invocation (i.e. when caller.wasSuccessful !== null). Slots ​ ​ default - Accepts the content whose visibility is controlled by the state of the supplied API Callers. It will be shown or hidden according to the flags defined for each caller. API Callers TIP (Vue 2 Only): Define the default slot as a scoped slot (e.g. with #default or v-slot:default on the c-loader-status) to prevent the VNode tree from being created when the content should be hidden. This improves performance and helps avoid null reference errors that can be caused when trying to render objects that haven't been loaded yet. scoped slot Previous pagec-list-range-display Next pagec-tablec-table ​ ​ A table component for displaying the contents of a ListViewModel. Also supports modifying the list's sort parameters by clicking on column headers. Pairs well with a c-list-pagination. ListViewModel sort parameters c-list-pagination Example Usage ​ ​ A simple table, rendering the items of a ListViewModel: ListViewModel A more complex example using more of the available options: Props ​ ​ list: ListViewModel  The ListViewModel to display pagination information for. ListViewModel props?: string[]  If provided, specifies which properties, and their ordering, should be given a column in the table. If not provided, all non-key columns that aren't annotated with [Hidden(HiddenAttribute.Areas.List)] are given a column. [Hidden(HiddenAttribute.Areas.List)] extraHeaders?: string[]  The text contents of one or more extra th elements to render in the table. Should be used in conjunction with the item.append slot. editable: boolean = false  If true, properties in each table cell will be rendered with c-input. Non-editable properties will be rendered in accordance with the value of the admin prop. c-input admin: boolean = false  If true, properties in each table cell will be rendered with c-admin-display instead of c-display. c-admin-display c-display Slots ​ ​ item.append - A slot rendered after the td elements on each row that render the properties of each item in the table. Should be provided zero or more additional td elements. The number should match the number of additional headers provided to the extraHeaders prop. Previous pagec-loader-status Next pagec-inputc-input ​ ​ A general-purpose input component for most Values. c-input delegates to other components based on the type of value it is bound to. This includes both other Coalesce Vuetify Components as well as direct usages of some Vuetify components. Values Coalesce Vuetify Components Vuetify All attributes are passed through to the delegated-to component, allowing for full customization of the underlying Vuetify component. Vuetify A summary of the components delegated to, by type: string: v-textarea if flag attribute textarea is provided to c-input or if [DataType(DataType.MultilineText)] is present in C#.Otherwise, v-text-field. Additionally, [DataTypeAttribute] values of DataType.EmailAddress, DataType.PhoneNumber, DataType.Password, or "Color" on the field will apply appropriate adjustments to the field.number: v-text-field.boolean: v-switch, or v-checkbox if flag attribute checkbox is provided to c-input.enum: v-selectfile: v-file-inputdate: c-datetime-pickermodel: c-select[ManyToMany] collection: c-select-many-to-manyNon-object collection: c-select-values string: v-textarea if flag attribute textarea is provided to c-input or if [DataType(DataType.MultilineText)] is present in C#.Otherwise, v-text-field. Additionally, [DataTypeAttribute] values of DataType.EmailAddress, DataType.PhoneNumber, DataType.Password, or "Color" on the field will apply appropriate adjustments to the field. v-textarea if flag attribute textarea is provided to c-input or if [DataType(DataType.MultilineText)] is present in C#.Otherwise, v-text-field. Additionally, [DataTypeAttribute] values of DataType.EmailAddress, DataType.PhoneNumber, DataType.Password, or "Color" on the field will apply appropriate adjustments to the field. v-textarea if flag attribute textarea is provided to c-input or if [DataType(DataType.MultilineText)] is present in C#. v-textarea Otherwise, v-text-field. Additionally, [DataTypeAttribute] values of DataType.EmailAddress, DataType.PhoneNumber, DataType.Password, or "Color" on the field will apply appropriate adjustments to the field. v-text-field number: v-text-field. v-text-field boolean: v-switch, or v-checkbox if flag attribute checkbox is provided to c-input. v-switch v-checkbox enum: v-select v-select file: v-file-input v-file-input date: c-datetime-picker c-datetime-picker model: c-select c-select [ManyToMany] collection: c-select-many-to-many [ManyToMany] c-select-many-to-many Non-object collection: c-select-values c-select-values Any other unsupported type will simply be displayed with c-display, unless a default slot is provided - in that case, the default slot will be rendered instead. c-display default slot When bound to a ViewModel, the validation rules for the bound property will be obtained from the ViewModel and passed to Vuetify's rules prop. ViewModel validation rules ViewModel Vuetify Examples ​ ​ Typical usage, providing an object and a property on that object: Customizing the Vuetify component used: Vuetify Binding to API Caller args objects: API Caller Or, using a more verbose syntax: Binding to Data Source Parameters: Data Source Parameters Usage with v-model (this scenario is atypical - the model/for pair of props are used in almost all scenarios): Props ​ ​ for?: string | Property | Value  A metadata specifier for the value being bound. One of: A string with the name of the value belonging to model.A direct reference to a metadata object.A string in dot-notation that starts with a type name. A string with the name of the value belonging to model. A direct reference to a metadata object. A string in dot-notation that starts with a type name. model?: Model | DataSource  An object owning the value that was specified by the for prop. If provided, the input will be bound to the corresponding property on the model object. value?: any // Vue 2
modelValue?: any // Vue 3  If binding the component with v-model, accepts the value part of v-model. Slots ​ ​ default - Used to display fallback content if c-input does not support the type of the value being bound. Generally this does not need to be used, as you should avoid creating c-input components for unsupported types in the first place. Previous pagec-table Next pagec-datetime-pickerc-datetime-picker ​ ​ A general, all-purpose date/time input component that can be used either with models and metadata or as a standalone component using only v-model. models metadata Examples ​ ​ Props ​ ​ for?: string | DateProperty | DateValue  A metadata specifier for the value being bound. One of: A string with the name of the value belonging to model.A direct reference to a metadata object.A string in dot-notation that starts with a type name. A string with the name of the value belonging to model. A direct reference to a metadata object. A string in dot-notation that starts with a type name. model?: Model | DataSource  An object owning the value that was specified by the for prop. If provided, the input will be bound to the corresponding property on the model object. value?: Date // Vue 2
modelValue?: Date // Vue 3  If binding the component with v-model, accepts the value part of v-model. dateKind?: 'date' | 'time' | 'datetime' = 'datetime'  Whether the date is only a date, only a time, or contains significant date and time information. If the component was bound with metadata using the for prop, this will default to the kind specified by [DateType]. [DateType] dateFormat?: string  The format of the date that will be rendered in the component's text field, and the format that will be attempted first when parsing user input in the text field. Defaults to: M/d/yyyy h:mm a if dateKind == 'datetime',M/d/yyyy if dateKind == 'date', orh:mm a if dateKind == 'time'. M/d/yyyy h:mm a if dateKind == 'datetime', M/d/yyyy if dateKind == 'date', or h:mm a if dateKind == 'time'. WARNING When parsing a user's text input into the text field, c-datetime-picker will first attempt to parse it with the format specified by dateFormat, or the default as described above if not explicitly specified. If this fails, the date will be parsed with the Date constructor, but only if the dateKind is datetime or date. This works fairly well on all modern browsers, but can still occasionally have issues. c-datetime-picker tries its best to filter out bad parses from the Date constructor, like dates with a year earlier than 1000. Date constructor native?: boolean  True if a native HTML5 input should be used instead of a popup menu with Vuetify date/time pickers inside of it. sideBySide?: boolean  True if the calendar and clock should be shown side by side in the picker menu, rather than in separate tabs. readonly?: boolean  True if the component should be read-only. disabled?: boolean  True if the component should be disabled. Previous pagec-input Next pagec-list-filtersc-list-filters ​ ​ A component that provides an interface for modifying the filters prop of a ListViewModel's parameters. ListViewModel parameters Example Usage ​ ​ Props ​ ​ list: ListViewModel  The ListViewModel whose filters will be editable. ListViewModel Previous pagec-datetime-picker Next pagec-list-pagec-list-page ​ ​ A component that provides previous/next buttons and a text field for modifying the page parameter prop of a ListViewModel. parameter ListViewModel Example Usage ​ ​ Props ​ ​ list: ListViewModel  The ListViewModel whose current page will be changeable with the component. ListViewModel Previous pagec-list-filters Next pagec-list-page-sizec-list-page-size ​ ​ A component that provides an dropdown for modifying the pageSize parameter prop of a ListViewModel. parameter ListViewModel Example Usage ​ ​ Props ​ ​ list: ListViewModel  The ListViewModel whose pagination will be editable. ListViewModel pageSizes?: number[]  An optional list of available page sizes to offer through c-list-page-size. Defaults to [10, 25, 100]. c-list-page-size Previous pagec-list-page Next pagec-list-paginationc-list-pagination ​ ​ A component that provides an interface for modifying the pagination parameters of a ListViewModel. parameters ListViewModel This is a composite of c-list-page-size, c-list-range-display, and c-list-page, arranged horizontally. It is designed to be used above or below a table (e.g. c-table). c-list-page-size c-list-range-display c-list-page c-table Example Usage ​ ​ Props ​ ​ list: ListViewModel  The ListViewModel whose pagination will be editable. ListViewModel pageSizes?: number[]  An optional list of available page sizes to offer through c-list-page-size. Defaults to [10, 25, 100]. c-list-page-size Previous pagec-list-page-size Next pagec-selectc-select ​ ​ A dropdown component that allows for selecting values fetched from the generated /list API endpoints. Used for selecting values for foreign key and navigation properties, or for selecting arbitrary objects or primary keys without a parent or owning object. Examples ​ ​ Binding to a navigation property or foreign key of a model: Binding an arbitrary primary key value or an arbitrary object: Examples of other props: Props ​ ​ for: string | ForeignKeyProperty | ModelReferenceNavigationProperty | ModelType  A metadata specifier for the value being bound. One of: The name of a foreign key or reference navigation property belonging to model.The name of a model type.A direct reference to a metadata object.A string in dot-notation that starts with a type name that resolves to a foreign key or reference navigation property. The name of a foreign key or reference navigation property belonging to model. The name of a model type. A direct reference to a metadata object. A string in dot-notation that starts with a type name that resolves to a foreign key or reference navigation property. TIP When binding by a key value, if the corresponding object cannot be found (e.g. there is no navigation property, or the navigation property is null), c-select will automatically attempt to load the object from the server so it can be displayed in the UI. model?: Model  An object owning the value that was specified by the for prop. If provided, the input will be bound to the corresponding property on the model object. If for specifies a foreign key or reference navigation property, both the foreign key and the navigation property of the model will be updated when the selected value is changed. value?: any // Vue 2
modelValue?: any // Vue 3  When binding the component with v-model, accepts the value part of v-model. If for was specified as a foreign key, this will expect a key; likewise, if for was specified as a type or as a navigation property, this will expect an object. keyValue?: any  When bound with :key-value.sync="keyValue", allows binding the primary key of the selected object explicitly. objectValue?: any  When bound with :object-value.sync="objectValue", allows binding the selected object explicitly. clearable?: boolean  Whether the selection can be cleared or not, emitting null as the input value. If not specified and the component is bound to a foreign key or reference navigation property, defaults to whether or not the foreign key has a required validation rule defined in its Metadata. Metadata preselectFirst?: boolean = false  If true, then when the first list results for the component are received by the client just after the component is created, c-select will emit the first item in the list as the selected value. preselectSingle?: boolean = false  If true, then when the first list results for the component are received by the client just after the component is created, if the results contained exactly one item, c-select will emit that only item as the selected value. reloadOnOpen?: boolean = false  If true, the list results will be reloaded when the dropdown menu is opened. By default, list results are loaded when the component is mounted and also when any of its parameters change (either search input or the params prop). params?: ListParameters  An optional set of Data Source Standard Parameters to pass to API calls made to the server. Data Source Standard Parameters cache?: ResponseCachingConfiguration | boolean  If provided and non-false, enables response caching on the component's internal API callers. response caching create?: {
  getLabel: (search: string, items: TModel[]) => string | false,
  getItem: (search: string, label: string) => Promise<TModel>
}  A object containing a pair of methods that allowing users to create new items from directly within the c-select if a matching object is not found. The object must contain the following two methods. You should define these in your component's script section - don't try to define them inline in your component. create.getLabel: (search: string, items: TModel[]) => string | false  A function that will be called with the user's current search term, as well as the collection of currently loaded items being presented to the user as valid selection options. It should return either a string that will be presented to the user as an option in the dropdown that can be clicked to invoke the getItem function below, or it should return false to prevent such an option from being shown to the user. create.getItem: (search: string, label: string) => Promise<TModel>  A function that will be invoked when the user clicks the option in the dropdown list described by getLabel. It will be given the user's current search term as well as the value of the label returned from getLabel as parameters. It must perform the necessary operations to create the new object on the server and then return a reference to that object. For example: Slots ​ ​ #item="{ item, search }" - Slot used to customize the text of both items inside the list, as well as the text of selected items. By default, items are rendered with c-display. Slot is passed a parameter item containing a model instance, and search containing the current search query. c-display model instance #list-item="{ item, search }" - Slot used to customize the text of items inside the list. If not provided, falls back to the item slot. #selected-item="{ item, search }" - Slot used to customize the text of selected items. If not provided, falls back to the item slot. Previous pagec-list-pagination Next pagec-select-many-to-manyc-select-many-to-many ​ ​ A multi-select dropdown component that allows for selecting values fetched from the generated /list API endpoints for collection navigation properties that were annotated with [ManyToMany]. [ManyToMany] TIP It is unlikely that you'll ever need to use this component directly - it is highly recommended that you use c-input instead and let it delegate to c-select-many-to-many for you. c-input c-select-many-to-many Examples ​ ​ Props ​ ​ for: string | Property | Value  A metadata specifier for the value being bound. One of: A string with the name of the value belonging to model.A direct reference to a metadata object.A string in dot-notation that starts with a type name. A string with the name of the value belonging to model. A direct reference to a metadata object. A string in dot-notation that starts with a type name. Note c-select-many-to-many expects metadata for the "real" collection navigation property on a model. If you provide it the string you passed to [ManyToMany], an error wil be thrown. [ManyToMany] model?: Model  An object owning the value that was specified by the for prop. If provided, the input will be bound to the corresponding property on the model object. value?: any // Vue 2
modelValue?: any // Vue 3  If binding the component with v-model, accepts the value part of v-model. params?: ListParameters  An optional set of Data Source Standard Parameters to pass to API calls made to the server. Data Source Standard Parameters cache?: ResponseCachingConfiguration | boolean  If provided and non-false, enables response caching on the component's internal API caller. response caching Events ​ ​ The following events and automatic API calls are only used when bound to a model that has auto-saves enabled. auto-saves adding - Fired when a new item has been selected, but before the call to /save has completed.added - Fired when the call to /save has completed after adding a new item.deleting - Fired when an item has been removed, but before the call to /delete has completed.deleted - Fired when the call to /delete has completed after removing an item. adding - Fired when a new item has been selected, but before the call to /save has completed. added - Fired when the call to /save has completed after adding a new item. deleting - Fired when an item has been removed, but before the call to /delete has completed. deleted - Fired when the call to /delete has completed after removing an item. Previous pagec-select Next pagec-select-string-valuec-select-string-value ​ ​ A dropdown component that will present a list of suggested string values from a custom API endpoint. Allows users to input values that aren't provided by the endpoint. Effectively, this is a server-driven autocomplete list. Examples ​ ​ Props ​ ​ for: string | Property | Value  A metadata specifier for the value being bound. One of: A string with the name of the value belonging to model.A direct reference to a metadata object.A string in dot-notation that starts with a type name. A string with the name of the value belonging to model. A direct reference to a metadata object. A string in dot-notation that starts with a type name. model: Model  An object owning the value that was specified by the for prop. If provided, the input will be bound to the corresponding property on the model object. method: string  The camel-cased name of the Custom Method to invoke to get the list of valid values. Will be passed a single string parameter search. Must be a static method on the type of the provided model object that returns a collection of strings. Custom Method params?: DataSourceParameters  An optional set of Data Source Standard Parameters to pass to API calls made to the server. Data Source Standard Parameters listWhenEmpty?: boolean = false  True if the method should be invoked and the list displayed when the entered search term is blank. eager?: boolean = false  True if the bound value should be updated as the user types. Otherwise, the bound value is updated when focus is lost or when a suggested value is chosen. This is only applicable for Vuetify 2 - in Vuetify 3, this is the default behavior. Previous pagec-select-many-to-many Next pagec-select-valuesc-select-values ​ ​ A multi-select input component for collections of non-object values (primarily strings and numbers). TIP It is unlikely that you'll ever need to use this component directly - it is highly recommended that you use c-input instead and let it delegate to c-select-values for you. c-input c-select-values Examples ​ ​ Props ​ ​ for: string | CollectionProperty | CollectionValue  A metadata specifier for the value being bound. One of: A string with the name of the value belonging to model.A direct reference to a metadata object.A string in dot-notation that starts with a type name. A string with the name of the value belonging to model. A direct reference to a metadata object. A string in dot-notation that starts with a type name. model?: Model  An object owning the value that was specified by the for prop. value?: any // Vue 2
modelValue?: any // Vue 3  If binding the component with v-model, accepts the value part of v-model. Previous pagec-select-string-value Next pagec-admin-audit-log-pagec-admin-audit-log-page ​ ​ A full-featured page for interacting with Coalesce's Audit Logging. Presents a view similar to c-admin-table-page with content optimized for viewing audit log records. Designed to be routed to directly with vue-router. Audit Logging c-admin-table-page vue-router Examples ​ ​ Props ​ ​ type: string  The PascalCase name of your IAuditLog implementation. list?: ListViewModel  An optional ListViewModel that will be used if provided instead of the one the component will create automatically from the provided type prop. ListViewModel color: string = 'primary'  A Vuetify color name to be applied to the toolbar at the top of the page. Slots ​ ​ row-detail: { item: AuditLogViewModel }  A slot that can be used to replace the entire content of the Detail column on the page. row-detail-append: { item: AuditLogViewModel }  A slot that can be used to append additional content to the Detail column on the page. Previous pagec-select-values Next pagec-admin-displayc-admin-display ​ ​ Behaves the same as c-display, except any collection navigation properties will be rendered as links to an admin list page, and any models will be rendered as a link to an admin item page. c-display Links for collections are resolved from vue-router with a route name of coalesce-admin-list, a type route param containing the name of the collection's type, and a query parameter filter.<foreign key name> with a value of the primary key of the owner of the collection. This route is expected to resolve to a c-admin-table-page, which is setup by default by the template outlined in Getting Started with Vue. vue-router c-admin-table-page Getting Started with Vue Links for single models are resolved from vue-router with a route name of coalesce-admin-item, a type route param containing the name of the model's type, and a id route param containing the object's primary key. This route is expected to resolve to a c-admin-editor-page, which is setup by default by the template outlined in Getting Started with Vue. vue-router c-admin-editor-page Getting Started with Vue Examples ​ ​ Props ​ ​ Same as c-display. c-display Slots ​ ​ Same as c-display. c-display Previous pagec-admin-audit-log-page Next pagec-admin-editor-pagec-admin-editor-page ​ ​ A page for a creating/editing single ViewModel instance. Provides a c-admin-editor and a c-admin-methods for the instance. Designed to be routed to directly with vue-router. ViewModel c-admin-editor c-admin-methods vue-router Examples ​ ​ Props ​ ​ type: string  The PascalCase name of the type to be created/edited. id?: number | string  The primary key of the item being edited. If null or not provided, the page will be creating a new instance of the provided type instead. Previous pagec-admin-display Next pagec-admin-editorc-admin-editor ​ ​ An editor for a single ViewModel instance. Provides a c-input for each property of the model. ViewModel c-input Does not automatically enable auto-save - if desired, this must be enabled by the implementor of this component. auto-save Examples ​ ​ Props ​ ​ model: ViewModel | ListViewModel  The ViewModel to render an editor for. ViewModel Previous pagec-admin-editor-page Next pagec-admin-methodc-admin-method ​ ​ Provides an interface for invoking a method and rendering its result, designed to be use in an admin page. method For each parameter of a method, a c-input will be rendered to accept the input of that parameter. A button is provided to trigger an invocation of the method, progress and errors are rendered with a c-loader-status, and results are rendered with c-display. c-input c-loader-status c-display Examples ​ ​ Props ​ ​ for: string | Method  A metadata specifier for the method. One of: A string with the name of the method belonging to model.A direct reference to a method's metadata object.A string in dot-notation that starts with a type name and ending with a method name. A string with the name of the method belonging to model. A direct reference to a method's metadata object. A string in dot-notation that starts with a type name and ending with a method name. model: ViewModel | ListViewModel  An ViewModel or ListViewModel owning the method and API Caller that was specified by the for prop. ViewModel ListViewModel API Caller autoReloadModel?: boolean = false  True if the model should have its $load invoked after a successful invocation of the method. Previous pagec-admin-editor Next pagec-admin-methodsc-admin-methods ​ ​ Renders in a Vuetify v-expansion-panels a c-admin-method for each method on a ViewModel or ListViewModel. Vuetify v-expansion-panels c-admin-method ViewModel ListViewModel Examples ​ ​ Props ​ ​ model: ViewModel | ListViewModel  An ViewModel or ListViewModel whose methods should each render as a c-admin-method. ViewModel ListViewModel c-admin-method autoReloadModel?: boolean = false  True if the model should have its $load invoked after a successful invocation of any method. Previous pagec-admin-method Next pagec-admin-table-pagec-admin-table-page ​ ​ A full-featured page for interacting with a ListViewModel. Provides a c-admin-table and a c-admin-methods for the list. Designed to be routed to directly with vue-router. ListViewModel c-admin-table c-admin-methods vue-router Examples ​ ​ Props ​ ​ type: string  The PascalCase name of the type to be listed. list?: ListViewModel  An optional ListViewModel that will be used if provided instead of the one the component will otherwise create automatically. ListViewModel Previous pagec-admin-methods Next pagec-admin-table-toolbarc-admin-table-toolbar ​ ​ A full-featured toolbar for a ListViewModel designed to be used on an admin page, including "Create" and "Reload" buttons, a c-list-range-display, a c-list-page, a search field, c-list-filters, and a c-list-page-size. ListViewModel c-list-range-display c-list-page c-list-filters c-list-page-size Examples ​ ​ Props ​ ​ list: ListViewModel  The ListViewModel to render the toolbar for. ListViewModel color: string = 'primary'  The color of the toolbar. color editable?: boolean  If provided, adds a button to toggle the value of this prop. Should be bound with the .sync modifier. Previous pagec-admin-table-page Next pagec-admin-tablec-admin-table ​ ​ An full-featured table for a ListViewModel, including a c-admin-table-toolbar, c-table, and c-list-pagination. ListViewModel c-admin-table-toolbar c-table c-list-pagination The table can be in read mode (default), or toggled into edit mode with the button provided by the c-admin-table-toolbar. When placed into edit mode, auto-save is enabled. c-admin-table-toolbar auto-save Examples ​ ​ Props ​ ​ list: ListViewModel  The ListViewModel to render a table for. ListViewModel pageSizes?: number[]  An optional list of available page sizes to offer through the c-list-pagination's c-list-page-size component. Defaults to [10, 25, 100]. c-list-pagination c-list-page-size queryBind?: boolean  If true, the Data Source Standard Parameters of the provided ListViewModel will be read from and written to the window's query string. The "Editable" state of the table will also be bound to the query string. Data Source Standard Parameters ListViewModel Previous pagec-admin-table-toolbar Next pageAudit LoggingAudit Logging ​ ​ Keeping a history of all (or most) of the changes that are made to records in your database can be invaluable, both for non-repudiation (i.e. proving what happened and who did it), and for troubleshooting or debugging. non-repudiation Coalesce provides a package IntelliTect.Coalesce.AuditLogging that adds an easy way to inject this kind of audit logging into your EF Core DbContext. It also includes an out-of-the-box view c-admin-audit-log-page that enables browsing of this data on the frontend. c-admin-audit-log-page Setup ​ ​ In this setup process, we're going to add an additional Coalesce Nuget package, define a custom entity to hold our audit logs, install the audit logging extension into our DbContext, and add a pre-made interface on the frontend to view our logs. 1. Add the NuGet package ​ ​ Add a reference to the Nuget package IntelliTect.Coalesce.AuditLogging to your data project: 2. Define the log entity ​ ​ Define the entity type that will hold the audit records in your database: This entity only needs to implement IAuditLog, but a default implementation of this interface DefaultAuditLog is provided for your convenience. DefaultAuditLog contains additional properties ClientIp, Referrer, and Endpoint for recording information about the HTTP request (if available), and also comes pre-configured for security with Create, Edit, and Delete APIs disabled. You should further augment this type with any additional properties that you would like to track on each change record. A property to track the user who performed the change should be added, since it is not provided by the default implementation so that you can declare it yourself with the correct type for the foreign key and navigation property. You should also apply security to restrict reading of these records to only the most privileged users with a Read Attribute (as in the example above) and/or a custom Default Data Source. Read Attribute custom Default Data Source 3. Configure your DbContext ​ ​ On your DbContext, implement the IAuditLogDbContext<AuditLog> interface using the class you just created as the type parameter. Then register the Coalesce audit logging extension in your DbContext's OnConfiguring method so that saves will be intercepted and audit log entries created. You could also perform this setup in your web project when calling .AddDbContext(). The above code also contains a reference to a class OperationContext. This is the service that will allow you to populate additional custom properties on your audit entries. You'll want to define it as follows: When you're inheriting from DefaultAuditLog for your IAuditLog implementation, you'll want to similarly inherit from DefaultAuditOperationContext<> for your operation context. It will take care of populating the HTTP request tracking fields on the AuditLog record. If you want a totally custom implementation, you only need to implement the IAuditOperationContext<TAuditLog> interface. The operation context class passed to WithAugmentation will be injected from the application service provider if available; otherwise, a new instance will be constructed using dependencies from the application service provider. To make an injected dependency optional, make the constructor parameter nullable with a default value of null, or create alternate constructors. alternate constructors 4. Add the UI ​ ​ For Vue applications, the c-admin-audit-log-page component provides an out-of-the-box user interface for browsing through audit logs. Simply define the following route in your application's router: c-admin-audit-log-page Configuration ​ ​ Suppression ​ ​ You can turn audit logging on or off for individual operations by implementing the SuppressAudit property on your DbContext. For example, implement it as an auto-property as follows and then set it to true in application code when desired: Exclusions & Formatting ​ ​ Coalesce's audit logging is built on top of Entity Framework Plus and can be configured using all of its configuration, including includes/excludes and custom property formatting. Entity Framework Plus configuration includes/excludes custom property formatting Coalesce will not use EF Plus's AuditManager.DefaultConfiguration global singleton instance. You must use Coalesce's configuration extensions which allow for more targeted configuration per context that does not rely on a global static singleton. For example: Property Descriptions ​ ​ The AuditLogProperty children of your IAuditLog implementation have two properties OldValueDescription and NewValueDescription that can be used to hold a description of the old and new values. By default, Coalesce will populate the descriptions of foreign key properties with the List Text of the referenced principal entity. This greatly improves the usability of the audit logs, which would otherwise only show meaningless numbers or GUIDs for foreign keys that changed. List Text This feature will load principal entities into the DbContext if they are not already loaded, which could inflict subtle differences in application functionality in rare edge cases if your application is making assumptions about navigation properties not being loaded. Typically though, this will not be an issue and will not lead unintentional information disclosure to clients as long as IncludeTrees are used correctly. IncludeTree This feature may be disabled by calling .WithPropertyDescriptions(PropertyDescriptionMode.None) inside your call to .UseCoalesceAuditLogging(...) in your DbContext configuration. You may also populate these descriptions in your IAuditOperationContext implementation that was provided to .WithAugmentation<T>(). Merging ​ ​ When using a supported database provider (currently only SQL Server), audit records for changes to the same entity will be merged together when the change is identical in all aspects to the previous audit record for that entity, with the sole exception of the old/new property values. In other words, if the same user is making repeated changes to the same property on the same entity from the same page, then those changes will merge together into one audit record. This merging only happens together if the existing audit record is recent; the default cutoff for this is 30 seconds, but can be configured with .WithMergeWindow(TimeSpan.FromSeconds(15)) when calling UseCoalesceAuditLogging. It can also be turned off by setting this value to TimeSpan.Zero. The merging logic respects all custom properties you add to your IAuditLog implementation, requiring their values to match between the existing and new audit records for a merge to occur. Caveats ​ ​ Only changes that are tracked by the DbContext's ChangeTracker can be audited. Changes that are made with raw SQL, or changes that are made with bulk update functions like ExecuteUpdate or ExecuteDelete will not be audited using this package. ExecuteUpdate or ExecuteDelete Audit Stamping ​ ​ A lightweight alternative or addition to full audit logging is audit stamping - the process of setting fields like CreatedBy or ModifiedOn on each changed entity. This cannot record a history of exact changes, but can at least record the age of an entity and how recently it changed. Coalesce offers a simple mechanism to register an Entity Framework save interceptor to perform this kind of action (this does NOT require the IntelliTect.Coalesce.AuditLogging package). This mechanism operations on all saves that go through Entity Framework, eliminating the need to perform this manually in individual Behaviors, Services, and Custom Methods: In the above example, TrackingBase is an interface or class that you would write as part of your application that defines the properties and mechanisms for performing the tracking operation. For example: The overload UseStamping<TStampable> will provide the ClaimsPrincipal from the current HTTP request if present, defaulting to null if an operation occurs outside an HTTP request (e.g. a background job). The overloads UseStamping<TStampable, TService> and UseStamping<TStampable, TService1, TService2> can be used to inject services into the operation. If more than two services are needed, you should wrap those dependencies up into an additional services that takes them as dependencies. Previous pagec-admin-table Next pageConfig: ASP.NET CoreApplication Configuration ​ ​ In order for Coalesce to work in your application, you must register the needed services in your Startup.cs or Program.cs. Doing so is simple: This registers all the basic services that Coalesce needs in order to work with your EF DbContext. However, there are many more options available. Here's a more complete invocation of AddCoalesce that takes advantage of many of the options available: Available builder methods include: public Builder AddContext<TDbContext>()  Register services needed by Coalesce to use the specified context. This is done automatically when calling the services.AddCoalesce<AppDbContext>(); overload. public Builder UseDefaultDataSource(Type dataSource)  Overrides the default data source used, replacing the Standard Data Source. See Data Sources for more details. Standard Data Source Data Sources public Builder UseDefaultBehaviors(Type behaviors)  Overrides the default behaviors used, replacing the Standard Behaviors. See Behaviors for more details. Standard Behaviors Behaviors public Builder UseTimeZone(TimeZoneInfo timeZone)  Specify a static time zone that should be used when Coalesce is performing operations on dates/times that lack timezone information. For example, when a user inputs a search term that contains only a date, Coalesce needs to know what timezone's midnight to use when performing the search. public Builder UseTimeZone<ITimeZoneResolver>()  Specify a service implementation to use to resolve the current timezone. This should be a scoped service, and will be automatically registered if it is not already. This allows retrieving timezone information on a per-request basis from HTTP headers, Cookies, or any other source. public Builder Configure(Action<CoalesceOptions> setupAction)  Configure additional options for Coalesce runtime behavior. Current options include options for server-side validation, and options for exception handling. See individual members for details. Previous pageAudit Logging Next pageConfig: Code GenCode Generation Configuration ​ ​ In Coalesce, all configuration of the code generation is done in a JSON file. This file is typically named coalesce.json and is typically placed in the solution root. File Resolution ​ ​ When the code generation is run by invoking dotnet coalesce, Coalesce will try to find a configuration file via the following means: If an argument is specified on the command line, it will be used as the location of the file. E.g. dotnet coalesce C:/Projects/MyProject/config.jsonIf no argument is given, Coalesce will try to use a file in the working directory named coalesce.jsonIf no file is found in the working directory, Coalesce will crawl up the directory tree from the working directory until a file named coalesce.json is found. If such a file is never found, an error will be thrown. If an argument is specified on the command line, it will be used as the location of the file. E.g. dotnet coalesce C:/Projects/MyProject/config.json If no argument is given, Coalesce will try to use a file in the working directory named coalesce.json If no file is found in the working directory, Coalesce will crawl up the directory tree from the working directory until a file named coalesce.json is found. If such a file is never found, an error will be thrown. Contents ​ ​ A full example of a coalesce.json file, along with an explanation of each property, is as follows: Additional CLI Options ​ ​ There are a couple of extra options which are only available as CLI parameters to dotnet coalesce. These options do not affect the behavior of the code generation - only the behavior of the CLI itself. --debug When this flag is specified when running dotnet coalesce, Coalesce will wait up to 60 seconds for a debugger to be attached to its process before starting code generation. -v|--verbosity <level> Set the verbosity of the output. Options are trace, debug, information, warning, error, critical, and none. Previous pageConfig: ASP.NET Core Next pageGenerated CodeCode Generation Overview ​ ​ Coalesce's principal purpose is a code generation framework for automating the creation of the boring-but-necessary parts of a web application. Below, you find an overview of the different components of Coalesce's code generation features. Running Code Generation ​ ​ Coalesce's code generation is ran via a dotnet CLI tool, dotnet coalesce. In order to invoke this tool, you must have the appropriate references to the package that provides it in your .csproj file: CLI Options ​ ​ All configuration of the way that Coalesce interacts with your projects, including locating, analyzing, and producing generated code, is done in a json configuration file, coalesce.json. Read more about this file at Code Generation Configuration. Code Generation Configuration There are a couple of extra options which are only available as CLI parameters to dotnet coalesce. These options do not affect the behavior of the code generation - only the behavior of the CLI itself. --debug - When this flag is specified when running dotnet coalesce, Coalesce will wait for a debugger to be attached to its process before starting code generation. -v|--verbosity <level> - Set the verbosity of the output. Options are trace, debug, information, warning, error, critical, and none. Generated Code ​ ​ Coalesce will generate a full vertical stack of code for you: Backend C# ​ ​ API Controllers ​ ​ For each of your Entity Models, Custom DTOs, and Services, an API controller is created in the /Api/Generated directory of your web project. These controllers provide a number of endpoints for interacting with your data. Entity Models Custom DTOs Services These controllers can be secured at a high level using Security Attributes, and when applicable to the type, with Data Sources and Behaviors. Security Attributes Data Sources Behaviors C# DTOs ​ ​ For each of your Entity Models, a C# DTO class is created. These classes are used to hold the data that will be serialized and sent to the client, as well as data that has been received from the client before it has been mapped back to your EF POCO class. Entity Models See Generated C# DTOs for more information. Generated C# DTOs Frontend - Vue ​ ​ An overview of the Vue generated code can be found at Vue Overview. Vue Overview Frontend - Knockout ​ ​ An overview of the legacy Knockout generated code can be found at Knockout Overview. Knockout Overview Previous pageConfig: Code Gen Next pageGenerated C# DTOsGenerated C# DTOs ​ ​ Data Transfer Objects, or DTOs, allow for transformations of data from the data store into a format more suited for transfer and use on the client side. This often means trimming properties and flattening structures to provide a leaner over-the-wire experience. Coalesce aims to support this as seamlessly as possible. Coalesce supports two types of DTOs: DTOs that are automatically generated for each POCO database object. These are controlled via Attributes on the POCO. These are outlined below.DTOs that you create with IClassDto. These are outlined at Custom DTOs. DTOs that are automatically generated for each POCO database object. These are controlled via Attributes on the POCO. These are outlined below. Attributes DTOs that you create with IClassDto. These are outlined at Custom DTOs. Custom DTOs Automatically Generated DTOs ​ ​ Every class that is exposed through Coalesce's generated API will have a corresponding DTO generated for it. These DTOs are used to shuttle data back and forth to the client. They are generated classes that have nullable versions of all the properties on the POCO class. [DtoIncludes] & [DtoExcludes] and the Includes String infrastructure can be used to indicate which properties should be transferred to the client in which cases, and Include Tree is used to dictate how these DTOs are constructed from POCOs retrieved from the database. [DtoIncludes] & [DtoExcludes] Includes String Include Tree The [Read] and [Edit] attributes can be used to apply property-level security, which manifests as conditional logic in the mapping methods on the generated DTOs. [Read] and [Edit] attributes See the Security page to read more about property-level security, as well as all other security mechanisms in Coalesce. Security Previous pageGenerated Code Next pageInclude TreeInclude Tree ​ ​ When Coalesce maps from the your POCO objects that are returned from EF Core queries, it will follow a structure called an IncludeTree to determine what relationships to follow and how deep to go in re-creating that structure in the mapped DTOs. Purpose ​ ​ Without an IncludeTree present, Coalesce will map the entire object graph that is reachable from the root object. This can often spiral out of control if there aren't any rules defining how far to go while turning this graph into a tree. For example, suppose you had the following model with a many-to-many relationship (key properties omitted for brevity): Now, imagine that you have five employees and five projects, with every employee being a member of every project (i.e. there are 25 EmployeeProject rows). Your client code makes a call to the Coalesce-generated API to load Employee #1 using the custom data source: VueKnockout Vue Knockout If you're already familiar with the fact that an IncludeTree is implicitly created in this scenario, then imagine for a moment that this is not the case (if you're not familiar with this fact, then keep reading!). After Coalesce has called your Data Sources and evaluated the EF IQueryable returned, there are now 35 objects loaded into the current DbContext being used to handle this request - the 5 employees, 5 projects, and 25 relationships. Data Sources To map these objects to DTOs, we start with the root (employee #1) and expand outward from there until the entire object graph has been faithfully re-created with DTO objects, including all navigation properties. The root DTO object (employee #1) then eventually is passed to the JSON serializer by ASP.NET Core to formulate the response to the request. As the object is serialized to JSON, the only objects that are not serialized are those that were already serialized as an ancestor of itself. What this ultimately means is that the structure of the serialized JSON with our example scenario ends up following a pattern like this (the vast majority of items have been omitted): See how the structure includes the EmployeeProjects of Employee#2? We didn't write our custom data source calls to .Include in such a way that indicated that we wanted the root employee, their projects, the employees of those projects, and then the projects of those employees. But, because the JSON serializer blindly follows the object graph, that's what gets serialized. It turns out that the depth of the tree increases on the order of O(n^2), and the total size increases on the order of Ω(n!). This is where IncludeTree comes in. When you use a custom data source like we did above, Coalesce automatically captures the structure of the calls to .Include and .ThenInclude, and uses this to perform trimming during creation of the DTO objects. With an IncludeTree in place, our new serialized structure looks like this: No more extra data trailing off the end of the projects' employees! Usage ​ ​ Custom Data Sources ​ ​ In most cases, you don't have to worry about creating an IncludeTree. When using the Standard Data Source (or a derivative), the structure of the .Include and .ThenInclude calls will be captured automatically and be turned into an IncludeTree. Standard Data Source However, there are sometimes cases where you perform complex loading in these methods that involves loading data into the current DbContext outside of the IQueryable that is returned from the method. The most common situation for this is needing to conditionally load related data - for example, load all children of an object where the child has a certain value of a Status property. In these cases, Coalesce provides a pair of extension methods, .IncludedSeparately and .ThenIncluded, that can be used to merge in the structure of the data that was loaded separately from the main IQueryable. For example: You can also override the GetIncludeTree method of the Standard Data Source to achieve the same result: Standard Data Source Model Methods ​ ​ If you have custom methods that return object data, you may also want to control the structure of the returned data when it is serialized. Fortunately, you can also use IncludeTree in these situations. Without an IncludeTree, the entire object graph is traversed and serialized without limit. custom methods TIP An IncludeTree can be obtained from any IQueryable by calling the GetIncludeTree extension method (using IntelliTect.Coalesce.Helpers.IncludeTree). In situations where your root object isn't on your DbContext (see External Types), you can use Enumerable.Empty<MyNonDbClass>().AsQueryable() to get an IQueryable to start from. When you do this, you must use IncludedSeparately - the regular EF Include method won't work without a DbSet. External Types See the following two techniques for returning an IncludeTree from a custom method: ItemResult.IncludeTree ​ ​ The easiest and most versatile way to return an IncludeTree from a custom method is to make that method return an ItemResult<T>, and then set the IncludeTree property of the ItemResult object. For example: Out Parameter ​ ​ To tell Coalesce about the structure of the data returned from a model method, you can also add out IncludeTree includeTree to the signature of the method. Inside your method, set includeTree to an instance of an IncludeTree. However, this approach cannot be used on async methods, since out parameters are not allowed on async methods in C#. For example: External Type Caveats ​ ​ One important point remains regarding IncludeTree - it is not used to control the serialization of objects which are not mapped to the database, known as External Types. External Types are always put into the DTOs when encountered (unless otherwise prevented by [DtoIncludes] & [DtoExcludes] or Security Attributes), with the assumption that because these objects are created by you (as opposed to Entity Framework), you are responsible for preventing any undesired circular references. External Types [DtoIncludes] & [DtoExcludes] Security Attributes By not filtering unmapped properties, you as the developer don't need to account for them in every place throughout your application where they appear - instead, they 'just work' and show up on the client as expected. Note also that this statement does not apply to database-mapped objects that hang off of unmapped objects - any time a database-mapped object appears, it will be controlled by your include tree. If no include tree is present (because nothing was specified for the unmapped property), these mapped objects hanging off of unmapped objects will be serialized freely and with all circular references, unless you include some calls to .IncludedSeparately(m => m.MyUnmappedProperty.MyMappedProperty) to limit those objects down. Previous pageGenerated C# DTOs Next pageIncludes StringIncludes String ​ ​ Coalesce provides a number of extension points for loading & serialization which make use of a concept called an "includes string" (also referred to as "include string" or just "includes"). Includes String ​ ​ The includes string is simply a string which can be set to any arbitrary value. It is passed from the client to the server in order to customize data loading and serialization. It can be set on both the TypeScript ViewModels and the ListViewModels. VueKnockout Vue Knockout The default value (i.e. no action) is the empty string. Special Values ​ ​ There are a few values of includes that are either set by default in the auto-generated views, or otherwise have special meaning: ValueDescription'none'Setting includes to none suppresses the Default Loading Behavior provided by the Standard Data Source - The resulting data will be the requested object (or list of objects) and nothing more.'admin-list'Used when loading a list of objects in the Vue admin list page.'admin-editor'Used when loading an object in the Vue admin editor component.'Editor'Used when loading an object in the generated Knockout CreateEdit views.'<ModelName>ListGen'Used when loading a list of objects in the generated Knockout Table and Cards views. For example, PersonListGen ValueDescription 'none'Setting includes to none suppresses the Default Loading Behavior provided by the Standard Data Source - The resulting data will be the requested object (or list of objects) and nothing more. 'none' Setting includes to none suppresses the Default Loading Behavior provided by the Standard Data Source - The resulting data will be the requested object (or list of objects) and nothing more. Default Loading Behavior Standard Data Source 'admin-list'Used when loading a list of objects in the Vue admin list page. 'admin-list' Used when loading a list of objects in the Vue admin list page. Vue admin list page 'admin-editor'Used when loading an object in the Vue admin editor component. 'admin-editor' Used when loading an object in the Vue admin editor component. Vue admin editor component 'Editor'Used when loading an object in the generated Knockout CreateEdit views. 'Editor' Used when loading an object in the generated Knockout CreateEdit views. '<ModelName>ListGen'Used when loading a list of objects in the generated Knockout Table and Cards views. For example, PersonListGen '<ModelName>ListGen' Used when loading a list of objects in the generated Knockout Table and Cards views. For example, PersonListGen DtoIncludes & DtoExcludes ​ ​ Main document: [DtoIncludes] & [DtoExcludes]. [DtoIncludes] & [DtoExcludes] There are two C# attributes, DtoIncludes and DtoExcludes, that can be used to annotate your data model in order to customize what data gets put into the DTOs and ultimately serialized to JSON and sent out to the client. When the database entries are returned to the client they will be trimmed based on the requested includes string and the values in DtoExcludes and DtoIncludes. DANGER These attributes are not security attributes - consumers of your application's API can set the includes string to any value when making a request. Do not use them to keep certain data private - use the Security Attributes family of attributes for that. Security Attributes It is important to note that the value of the includes string will match against these attributes on any of your models that appears in the object graph being mapped to DTOs - it is not limited only to the model type of the root object. Important DtoIncludes does not ensure that specific data will be loaded from the database. It only permits what is already loaded into the current EF DbContext to be returned from the API. See Data Sources to learn how to control what data gets loaded from the database. Data Sources Example Usage ​ ​ Server code: Client code: VueKnockout Vue Knockout Properties ​ ​ // Also settable via constructor parameter #1
public string ContentViews { get; set; }  A comma-delimited list of values of includes on which to operate. includes For DtoIncludes, this will be the values of includes for which this property will be allowed to be serialized and sent to the client. For DtoExcludes, this will be the values of includes for which this property will not be serialized and sent to the client. Previous pageInclude Tree Next pageVue 2 to Vue 3Vue 2 to Vue 3 ​ ​ If you're already experienced with Vue 2 but are new to Vue 3, or if you're migrating an existing Vue 2 app to Vue 3, you should first read through the official migration guide. official migration guide Vuetify also offers a migration guide to upgrade from Vuetify 2 to Vuetify 3. migration guide If you're new to Vue entirely, check out the rest of Vue docs and pick your learning path. pick your learning path Coalesce Upgrade Steps ​ ​ The changes specific to Coalesce when migrating from Vue2 to Vue3 are pretty minimal. Most of your work will be in following the Vue 3 Migration Guide and the Vuetify 3 Migration Guide. Vue 3 Migration Guide Vuetify 3 Migration Guide The table below contains the Coalesce-specific changes when migrating to Vue 3. However, the easiest migration path may be to disregard the table below and instead, instantiate the Coalesce Vue template or look at it on GitHub and compare individual files between your project and the template side by side and ingest the changes that you observe. instantiate the Coalesce Vue template look at it on GitHub LocationOld (Vue 2)New (Vue 3)package.jsonjson{
  "dependencies": {
    "coalesce-vue-vuetify2": "x"
  }
}json{
  "dependencies": {
    "coalesce-vue-vuetify3": "x"
  }
}vite.config.tstsimport { CoalesceVuetifyResolver } from "coalesce-vue-vuetify2/lib/build"tsimport { CoalesceVuetifyResolver } from "coalesce-vue-vuetify3/build"

// Custom SASS options and `optimizeDeps` configuration can be removed
// since Vuetify3 no longer uses deprecated sass features,
// and pre-bundling styles no longer has appreciable benefit.main.tstsimport "coalesce-vue-vuetify2/dist/coalesce-vue-vuetify.css"

// Either of these:
import CoalesceVuetify from 'coalesce-vue-vuetify2/lib'
import CoalesceVuetify from 'coalesce-vue-vuetify2'

Vue.use(CoalesceVuetify, {
  metadata: $metadata,
});tsimport "coalesce-vue-vuetify3/styles.css"


import { createCoalesceVuetify } from "coalesce-vue-vuetify3";


const coalesceVuetify = createCoalesceVuetify({
  metadata: $metadata,
});
app.use(coalesceVuetify);router.tsts// Either of these:
import { CAdminTablePage, CAdminEditorPage } from 'coalesce-vue-vuetify2/lib';
import { CAdminTablePage, CAdminEditorPage } from 'coalesce-vue-vuetify2';ts
import { CAdminEditorPage, CAdminTablePage } from "coalesce-vue-vuetify3";Vitest/Jest testsIf you had a global test setup file performing Vue configuration, you can likely remove it entirely, or at least remove the parts that configure Vue. Vue3 does not operate on global configuration like Vue2 did.See test-utils.ts and HelloWorld.spec.ts in the template for examples of Vue3 component testing. LocationOld (Vue 2)New (Vue 3) package.jsonjson{
  "dependencies": {
    "coalesce-vue-vuetify2": "x"
  }
}json{
  "dependencies": {
    "coalesce-vue-vuetify3": "x"
  }
} package.json package.json json{
  "dependencies": {
    "coalesce-vue-vuetify2": "x"
  }
} json{
  "dependencies": {
    "coalesce-vue-vuetify3": "x"
  }
} vite.config.tstsimport { CoalesceVuetifyResolver } from "coalesce-vue-vuetify2/lib/build"tsimport { CoalesceVuetifyResolver } from "coalesce-vue-vuetify3/build"

// Custom SASS options and `optimizeDeps` configuration can be removed
// since Vuetify3 no longer uses deprecated sass features,
// and pre-bundling styles no longer has appreciable benefit. vite.config.ts vite.config.ts tsimport { CoalesceVuetifyResolver } from "coalesce-vue-vuetify2/lib/build" tsimport { CoalesceVuetifyResolver } from "coalesce-vue-vuetify3/build"

// Custom SASS options and `optimizeDeps` configuration can be removed
// since Vuetify3 no longer uses deprecated sass features,
// and pre-bundling styles no longer has appreciable benefit. main.tstsimport "coalesce-vue-vuetify2/dist/coalesce-vue-vuetify.css"

// Either of these:
import CoalesceVuetify from 'coalesce-vue-vuetify2/lib'
import CoalesceVuetify from 'coalesce-vue-vuetify2'

Vue.use(CoalesceVuetify, {
  metadata: $metadata,
});tsimport "coalesce-vue-vuetify3/styles.css"


import { createCoalesceVuetify } from "coalesce-vue-vuetify3";


const coalesceVuetify = createCoalesceVuetify({
  metadata: $metadata,
});
app.use(coalesceVuetify); main.ts main.ts tsimport "coalesce-vue-vuetify2/dist/coalesce-vue-vuetify.css"

// Either of these:
import CoalesceVuetify from 'coalesce-vue-vuetify2/lib'
import CoalesceVuetify from 'coalesce-vue-vuetify2'

Vue.use(CoalesceVuetify, {
  metadata: $metadata,
}); tsimport "coalesce-vue-vuetify3/styles.css"


import { createCoalesceVuetify } from "coalesce-vue-vuetify3";


const coalesceVuetify = createCoalesceVuetify({
  metadata: $metadata,
});
app.use(coalesceVuetify); router.tsts// Either of these:
import { CAdminTablePage, CAdminEditorPage } from 'coalesce-vue-vuetify2/lib';
import { CAdminTablePage, CAdminEditorPage } from 'coalesce-vue-vuetify2';ts
import { CAdminEditorPage, CAdminTablePage } from "coalesce-vue-vuetify3"; router.ts router.ts ts// Either of these:
import { CAdminTablePage, CAdminEditorPage } from 'coalesce-vue-vuetify2/lib';
import { CAdminTablePage, CAdminEditorPage } from 'coalesce-vue-vuetify2'; ts
import { CAdminEditorPage, CAdminTablePage } from "coalesce-vue-vuetify3"; Vitest/Jest testsIf you had a global test setup file performing Vue configuration, you can likely remove it entirely, or at least remove the parts that configure Vue. Vue3 does not operate on global configuration like Vue2 did.See test-utils.ts and HelloWorld.spec.ts in the template for examples of Vue3 component testing. Vitest/Jest tests Vitest/Jest tests If you had a global test setup file performing Vue configuration, you can likely remove it entirely, or at least remove the parts that configure Vue. Vue3 does not operate on global configuration like Vue2 did. If you had a global test setup file performing Vue configuration, you can likely remove it entirely, or at least remove the parts that configure Vue. Vue3 does not operate on global configuration like Vue2 did. See test-utils.ts and HelloWorld.spec.ts in the template for examples of Vue3 component testing. See test-utils.ts and HelloWorld.spec.ts in the template for examples of Vue3 component testing. test-utils.ts HelloWorld.spec.ts From Class Components to <script setup> ​ ​ The components in the Coalesce template for Vue 3 have switched from vue-class-component to Vue Composition API with <script setup>, the official recommendation for building full Vue 3 applications. official recommendation If you're used to writing components in Vue 2 with vue-class-component and vue-property-decorator, you can use this table of comparisons as a quick reference of what the equivalent features are using <script setup> and Vue Composition API. That said, this is not a replacement for learning and understanding the composition API. You should read the Composition API FAQ as well as the Reactivity Fundamentals documentation (make sure to set the API preference in the top left to Composition!). <script setup> Vue Composition API Composition API FAQ Reactivity Fundamentals If you'd like to continue using class components with Vue 3 (e.g. upgrading an existing project where rewriting all components is not feasible), you can try switching to vue-facing-decorator. vue-facing-decorator Note The examples below assume that unplugin-auto-import is being used (included in the Coalesce Vue3 template), eliminating the need to manually import common Vue Composition API functions. FeatureClass ComponentScript SetupCoalesce ViewModel and ListViewModel usagevue<script lang="ts">
import { Vue, Component } from "vue-property-decorator";
import { PersonViewModel, PersonListViewModel } from "@/viewmodels.g";

@Component({})
export default class MyComponent extends Vue {
  public person = new PersonViewModel();
  public list = new PersonListViewModel();

  async created() {
    await person.$load();
    await list.$load();

    person.$startAutoSave(this);
    list.$startAutoLoad(this);
  }
}
</script>vue<script lang="ts" setup>
import { PersonViewModel, PersonListViewModel } from "@/viewmodels.g";

const person = new PersonViewModel();
const list = new PersonListViewModel();

person.$useAutoSave();
list.$useAutoLoad();

// If you need to await an async operation during component creation, 
// use an IIFE so that the component mount is not delayed.
(async function created() {
  await person.$load();
  await list.$load();
})();
</script>@Prop, @Watchvue<script lang="ts">
import { Vue, Component, Prop, Watch } from "vue-property-decorator";

@Component({})
export default class MyComponent extends Vue {
  @Prop({ default: "Student" })
  label!: string;

  @Prop({ required: true })
  student!: ApplicationUserViewModel;

  @Watch("label")
  labelChanged(newVal, oldVal) {
    console.log(`label changed. new:${newVal}, old:${oldVal}`)
  }
}
</script>vue<script lang="ts" setup>
const props = withDefaults(defineProps<{
  label?: string,
  student?: ApplicationUserViewModel
}>(), { label: 'Student' })

watch(
  () => props.label,
  (newVal, oldVal) => {
    console.log(`label changed. new:${newVal}, old:${oldVal}`);
  }
);
</script>Reactive datavue<script lang="ts">
import { Vue, Component } from "vue-property-decorator";
import { PersonViewModel } from "@/viewmodels.g";

@Component({})
export default class MyComponent extends Vue {
  public person = new PersonViewModel();

  public checked = false;

  public items = [
    { name: "Foo", checked: false, },
    { name: "Bar", checked: true, }
  ]
}
</script>vue<script lang="ts" setup>
import { PersonViewModel } from "@/viewmodels.g";

// Properties on coalesce-generated ViewModels have built in reactivity 
// and don't need to be wrapped ref/reactive unless you're going to replace 
// the entire top level object with a different instance.
const person = new PersonViewModel();

const checked = ref(false);

const items = reactive([
  { name: "Foo", checked: false, },
  { name: "Bar", checked: true, }
])
</script>Computed valuesvue<script lang="ts">
import { Vue, Component } from "vue-property-decorator";
import { PersonViewModel } from "@/viewmodels.g";

@Component({})
export default class MyComponent extends Vue {
  public person = new PersonViewModel()

  get fullName() {
    return `${person.firstName} ${person.lastName}`
  }
}
</script>vue<script lang="ts" setup>
import { PersonViewModel } from "@/viewmodels.g";

const person = new PersonViewModel();

const fullName = computed(() => `${person.firstName} ${person.lastName}`)
</script>$emit, methodsvue<template>
  <input
    :value="value"
    @input="inputChanged($event.target.value)"
  />
</template>

<script lang="ts">
import { Vue, Component } from "vue-property-decorator";

@Component({})
export default class MyComponent extends Vue {
  @Prop()
  value!: string;

  inputChanged(v: string) {
    this.$emit('update:input', v)
  }
}
</script>vue<template>
  <input
    :value="modelValue"
    @input="inputChanged(($event.target as HTMLInputElement).value)"
  />
</template>

<script lang="ts" setup>
defineProps<{ modelValue: string | null }>();

// This may seem tedious, but it enables full Typescript intellisense!
const emit = defineEmits<{
  (e: "update:modelValue", value: string | null): void;
}>();

function inputChanged(v: string) {
  emit('update:modelValue', v)
}
</script> FeatureClass ComponentScript Setup Coalesce ViewModel and ListViewModel usagevue<script lang="ts">
import { Vue, Component } from "vue-property-decorator";
import { PersonViewModel, PersonListViewModel } from "@/viewmodels.g";

@Component({})
export default class MyComponent extends Vue {
  public person = new PersonViewModel();
  public list = new PersonListViewModel();

  async created() {
    await person.$load();
    await list.$load();

    person.$startAutoSave(this);
    list.$startAutoLoad(this);
  }
}
</script>vue<script lang="ts" setup>
import { PersonViewModel, PersonListViewModel } from "@/viewmodels.g";

const person = new PersonViewModel();
const list = new PersonListViewModel();

person.$useAutoSave();
list.$useAutoLoad();

// If you need to await an async operation during component creation, 
// use an IIFE so that the component mount is not delayed.
(async function created() {
  await person.$load();
  await list.$load();
})();
</script> Coalesce ViewModel and ListViewModel usage Coalesce ViewModel and ListViewModel usage vue<script lang="ts">
import { Vue, Component } from "vue-property-decorator";
import { PersonViewModel, PersonListViewModel } from "@/viewmodels.g";

@Component({})
export default class MyComponent extends Vue {
  public person = new PersonViewModel();
  public list = new PersonListViewModel();

  async created() {
    await person.$load();
    await list.$load();

    person.$startAutoSave(this);
    list.$startAutoLoad(this);
  }
}
</script> vue<script lang="ts" setup>
import { PersonViewModel, PersonListViewModel } from "@/viewmodels.g";

const person = new PersonViewModel();
const list = new PersonListViewModel();

person.$useAutoSave();
list.$useAutoLoad();

// If you need to await an async operation during component creation, 
// use an IIFE so that the component mount is not delayed.
(async function created() {
  await person.$load();
  await list.$load();
})();
</script> @Prop, @Watchvue<script lang="ts">
import { Vue, Component, Prop, Watch } from "vue-property-decorator";

@Component({})
export default class MyComponent extends Vue {
  @Prop({ default: "Student" })
  label!: string;

  @Prop({ required: true })
  student!: ApplicationUserViewModel;

  @Watch("label")
  labelChanged(newVal, oldVal) {
    console.log(`label changed. new:${newVal}, old:${oldVal}`)
  }
}
</script>vue<script lang="ts" setup>
const props = withDefaults(defineProps<{
  label?: string,
  student?: ApplicationUserViewModel
}>(), { label: 'Student' })

watch(
  () => props.label,
  (newVal, oldVal) => {
    console.log(`label changed. new:${newVal}, old:${oldVal}`);
  }
);
</script> @Prop, @Watch @Prop, @Watch vue<script lang="ts">
import { Vue, Component, Prop, Watch } from "vue-property-decorator";

@Component({})
export default class MyComponent extends Vue {
  @Prop({ default: "Student" })
  label!: string;

  @Prop({ required: true })
  student!: ApplicationUserViewModel;

  @Watch("label")
  labelChanged(newVal, oldVal) {
    console.log(`label changed. new:${newVal}, old:${oldVal}`)
  }
}
</script> vue<script lang="ts" setup>
const props = withDefaults(defineProps<{
  label?: string,
  student?: ApplicationUserViewModel
}>(), { label: 'Student' })

watch(
  () => props.label,
  (newVal, oldVal) => {
    console.log(`label changed. new:${newVal}, old:${oldVal}`);
  }
);
</script> Reactive datavue<script lang="ts">
import { Vue, Component } from "vue-property-decorator";
import { PersonViewModel } from "@/viewmodels.g";

@Component({})
export default class MyComponent extends Vue {
  public person = new PersonViewModel();

  public checked = false;

  public items = [
    { name: "Foo", checked: false, },
    { name: "Bar", checked: true, }
  ]
}
</script>vue<script lang="ts" setup>
import { PersonViewModel } from "@/viewmodels.g";

// Properties on coalesce-generated ViewModels have built in reactivity 
// and don't need to be wrapped ref/reactive unless you're going to replace 
// the entire top level object with a different instance.
const person = new PersonViewModel();

const checked = ref(false);

const items = reactive([
  { name: "Foo", checked: false, },
  { name: "Bar", checked: true, }
])
</script> Reactive data Reactive data vue<script lang="ts">
import { Vue, Component } from "vue-property-decorator";
import { PersonViewModel } from "@/viewmodels.g";

@Component({})
export default class MyComponent extends Vue {
  public person = new PersonViewModel();

  public checked = false;

  public items = [
    { name: "Foo", checked: false, },
    { name: "Bar", checked: true, }
  ]
}
</script> vue<script lang="ts" setup>
import { PersonViewModel } from "@/viewmodels.g";

// Properties on coalesce-generated ViewModels have built in reactivity 
// and don't need to be wrapped ref/reactive unless you're going to replace 
// the entire top level object with a different instance.
const person = new PersonViewModel();

const checked = ref(false);

const items = reactive([
  { name: "Foo", checked: false, },
  { name: "Bar", checked: true, }
])
</script> Computed valuesvue<script lang="ts">
import { Vue, Component } from "vue-property-decorator";
import { PersonViewModel } from "@/viewmodels.g";

@Component({})
export default class MyComponent extends Vue {
  public person = new PersonViewModel()

  get fullName() {
    return `${person.firstName} ${person.lastName}`
  }
}
</script>vue<script lang="ts" setup>
import { PersonViewModel } from "@/viewmodels.g";

const person = new PersonViewModel();

const fullName = computed(() => `${person.firstName} ${person.lastName}`)
</script> Computed values Computed values vue<script lang="ts">
import { Vue, Component } from "vue-property-decorator";
import { PersonViewModel } from "@/viewmodels.g";

@Component({})
export default class MyComponent extends Vue {
  public person = new PersonViewModel()

  get fullName() {
    return `${person.firstName} ${person.lastName}`
  }
}
</script> vue<script lang="ts" setup>
import { PersonViewModel } from "@/viewmodels.g";

const person = new PersonViewModel();

const fullName = computed(() => `${person.firstName} ${person.lastName}`)
</script> $emit, methodsvue<template>
  <input
    :value="value"
    @input="inputChanged($event.target.value)"
  />
</template>

<script lang="ts">
import { Vue, Component } from "vue-property-decorator";

@Component({})
export default class MyComponent extends Vue {
  @Prop()
  value!: string;

  inputChanged(v: string) {
    this.$emit('update:input', v)
  }
}
</script>vue<template>
  <input
    :value="modelValue"
    @input="inputChanged(($event.target as HTMLInputElement).value)"
  />
</template>

<script lang="ts" setup>
defineProps<{ modelValue: string | null }>();

// This may seem tedious, but it enables full Typescript intellisense!
const emit = defineEmits<{
  (e: "update:modelValue", value: string | null): void;
}>();

function inputChanged(v: string) {
  emit('update:modelValue', v)
}
</script> $emit, methods $emit, methods vue<template>
  <input
    :value="value"
    @input="inputChanged($event.target.value)"
  />
</template>

<script lang="ts">
import { Vue, Component } from "vue-property-decorator";

@Component({})
export default class MyComponent extends Vue {
  @Prop()
  value!: string;

  inputChanged(v: string) {
    this.$emit('update:input', v)
  }
}
</script> vue<template>
  <input
    :value="modelValue"
    @input="inputChanged(($event.target as HTMLInputElement).value)"
  />
</template>

<script lang="ts" setup>
defineProps<{ modelValue: string | null }>();

// This may seem tedious, but it enables full Typescript intellisense!
const emit = defineEmits<{
  (e: "update:modelValue", value: string | null): void;
}>();

function inputChanged(v: string) {
  emit('update:modelValue', v)
}
</script> Previous pageIncludes String Next pageKnockout OverviewKnockout Overview ​ ​ The Knockout stack for Coalesce offers the ability to build pages with the time-tested Knockout JavaScript library using all of the features of the Coalesce generated APIs and ViewModels. It can be used for anything between adding simple interactive augmentations of MVC pages to building a full MPA-SPA hybrid application. Knockout Knockout ViewModels Getting Started ​ ​ Check out Getting Started with Knockout if you haven't already to learn how to get a new Coalesce Knockout project up and running. Getting Started with Knockout Generated Code ​ ​ Below you will find a brief overview of each of the different pieces of code that Coalesce will generate for you when you choose the Knockout stack. TypeScript ​ ​ Coalesce generates a number of different types of TypeScript classes to support your data through the generated API. ViewModels ​ ViewModels ​ One view model class is generated for each of your Entity Models and Custom DTOs. These models contain fields for your model Properties, and functions and other members for your model Methods. They also contain a number of standard fields & functions inherited from BaseViewModel which offer basic loading & saving functionality, as well as other handy utility members for use with Knockout. Entity Models Custom DTOs Properties Methods See TypeScript ViewModels for more details. TypeScript ViewModels List ViewModels ​ List ViewModels ​ One ListViewModel is generated for each of your Entity Models and Custom DTOs. These classes contain functionality for loading sets of objects from the server. They provide searching, paging, sorting, and filtering functionality. Entity Models Custom DTOs See TypeScript ListViewModels for more details. TypeScript ListViewModels External Type ViewModels ​ External Type ViewModels ​ Any non-primitive types which are not themselves a Entity Models or Custom DTOs which are accessible through the aforementioned types, either through one of its Properties, or return value from one of its Methods, will have a corresponding TypeScript ViewModel generated for it. These ViewModels only provide a KnockoutObservable field for each property on the C# class. Entity Models Custom DTOs Properties Methods See TypeScript External ViewModels for more details. TypeScript External ViewModels View Controllers ​ ​ For each of your Entity Models and Custom DTOs, a controller is created in the /Controllers/Generated directory of your web project. These controllers provide routes for the generated admin views. Entity Models Custom DTOs As you add your own pages to your application, you should add additional partial classes in the /Controllers that extend these generated partial classes to expose those pages. Admin Views ​ ​ For each of your Entity Models and Custom DTOs, a number of views are generated to provide administrative-level access to your data. Entity Models Custom DTOs Table ​ ​ Provides a basic table view with sorting, searching, and paging of your data. Can be rendered in either read-only mode (routed as /Table), or editable mode (routed as TableEdit). Cards ​ ​ Provides a card-based view of your data with searching and paging. CreateEdit ​ ​ Provides an editor view which can be used to create new entities or edit existing ones. EditorHtml ​ ​ Provides a minimal amount of HTML to display an editor for the object type. This is used by the showEditor method on the generated TypeScript ViewModels. Previous pageVue 2 to Vue 3 Next pageGetting Started with KnockoutGetting Started with Knockout ​ ​ Creating a Project ​ ​ WARNING The Coalesce Knockout.js stack is deprecated and will be receiving only critical bug fixes going forward. You are strongly encouraged to start all new Coalesce projects with Vue. Vue The quickest and easiest way to create a new Coalesce Knockout application is to use the dotnet new template. In your favorite shell:  • View on GitHub  View on GitHub Data Modeling ​ ​ At this point, you can open up the newly-created solution in Visual Studio and run your application. However, your application won't do much without a data model, so you will probably want to do the following before running: Create an initial Data Model by adding EF entity classes to the data project and the corresponding DbSet<> properties to AppDbContext. You will notice that the starter project includes a single model, Widget, to start with. Feel free to change this model or remove it entirely. Read Entity Models for more information about creating a data model.Run dotnet ef migrations add Init (Init can be any name) in the data project to create an initial database migration.Run Coalesce's code generation by either:Running dotnet coalesce in the web project's root directoryRunning the coalesce npm script (Vue) or gulp task (Knockout) in the Task Runner Explorer Create an initial Data Model by adding EF entity classes to the data project and the corresponding DbSet<> properties to AppDbContext. You will notice that the starter project includes a single model, Widget, to start with. Feel free to change this model or remove it entirely. Read Entity Models for more information about creating a data model. Create an initial Data Model by adding EF entity classes to the data project and the corresponding DbSet<> properties to AppDbContext. You will notice that the starter project includes a single model, Widget, to start with. Feel free to change this model or remove it entirely. Read Entity Models for more information about creating a data model. Data Model Entity Models Run dotnet ef migrations add Init (Init can be any name) in the data project to create an initial database migration. Run dotnet ef migrations add Init (Init can be any name) in the data project to create an initial database migration. Run Coalesce's code generation by either:Running dotnet coalesce in the web project's root directoryRunning the coalesce npm script (Vue) or gulp task (Knockout) in the Task Runner Explorer Run Coalesce's code generation by either: Running dotnet coalesce in the web project's root directoryRunning the coalesce npm script (Vue) or gulp task (Knockout) in the Task Runner Explorer Running dotnet coalesce in the web project's root directory Running the coalesce npm script (Vue) or gulp task (Knockout) in the Task Runner Explorer You're now at a point where you can start creating your own pages! Building Pages & Features ​ ​ Lets say we've created a model called Person as follows, and we've ran code generation with dotnet coalesce: model We can create a details page for a Person by creating: A controller in src/MyApplication.Web/Controllers/PersonController.cs:c#namespace MyApplication.Web.Controllers
{
    public partial class PersonController
    {
        public IActionResult Details() => View();
    }
}A view in src/MyApplication.Web/Views/Person/Details.cshtml:razor<h1>Person Details</h1>

<div data-bind="with: person">
    <dl class="dl-horizontal">
        <dt>Name </dt>
        <dd data-bind="text: name"></dd>

        <dt>Date of Birth </dt>
        <dd data-bind="moment: birthDate, format: 'MM/DD/YYYY hh:mm a'"></dd>
    </dl>
</div>

@section Scripts
{
<script src="~/js/person.details.js"></script>
<script>
    $(function () {
        var vm = new MyApplication.PersonDetails();
        ko.applyBindings(vm);
        vm.load();
    });
</script>
}And a script in src/MyApplication.Web/Scripts/person.details.ts:ts/// <reference path="viewmodels.generated.d.ts" />

module MyApplication {
    export class PersonDetails {
        public person = new ViewModels.Person();

        load() {
            var id = Coalesce.Utilities.GetUrlParameter("id");
            if (id != null && id != '') {
                this.person.load(id);
            }
        }
    }
} A controller in src/MyApplication.Web/Controllers/PersonController.cs:c#namespace MyApplication.Web.Controllers
{
    public partial class PersonController
    {
        public IActionResult Details() => View();
    }
} A controller in src/MyApplication.Web/Controllers/PersonController.cs: A view in src/MyApplication.Web/Views/Person/Details.cshtml:razor<h1>Person Details</h1>

<div data-bind="with: person">
    <dl class="dl-horizontal">
        <dt>Name </dt>
        <dd data-bind="text: name"></dd>

        <dt>Date of Birth </dt>
        <dd data-bind="moment: birthDate, format: 'MM/DD/YYYY hh:mm a'"></dd>
    </dl>
</div>

@section Scripts
{
<script src="~/js/person.details.js"></script>
<script>
    $(function () {
        var vm = new MyApplication.PersonDetails();
        ko.applyBindings(vm);
        vm.load();
    });
</script>
} A view in src/MyApplication.Web/Views/Person/Details.cshtml: And a script in src/MyApplication.Web/Scripts/person.details.ts:ts/// <reference path="viewmodels.generated.d.ts" />

module MyApplication {
    export class PersonDetails {
        public person = new ViewModels.Person();

        load() {
            var id = Coalesce.Utilities.GetUrlParameter("id");
            if (id != null && id != '') {
                this.person.load(id);
            }
        }
    }
} And a script in src/MyApplication.Web/Scripts/person.details.ts: With these pieces in place, we now have a functioning page that will display details about a person. We can start up the application and navigate to /Person/Details?id=1 (assuming a person with ID 1 exists - if not, navigate to /Person/Table and create one). From this point, one can start adding more fields, more features, and more flair to the page. Check out all the other documentation in the sidebar to see what else Coalesce has to offer, including the Knockout Overview. Knockout Overview Previous pageKnockout Overview Next pageTypeScript ViewModelsTypeScript ViewModels ​ ​ For each database-mapped type in your model, Coalesce will generate a TypeScript class that provides a multitude of functionality for interacting with the data on the client. These ViewModels are dependent on Knockout, and are designed to be used directly from Knockout bindings in your HTML. All data properties on the generated model are Knockout observables. Knockout Base Members ​ ​ The following base members are available to all generated ViewModel classes: includes: string  String that will be passed to the server when loading and saving that allows for data trimming via C# Attributes. See Includes String. Includes String isChecked: KnockoutObservable<boolean>  Flag to use to determine if this item is checked. Only provided for convenience. isSelected: KnockoutObservable<boolean>  Flag to use to determine if this item is selected. Only provided for convenience. isEditing: KnockoutObservable<boolean>  Flag to use to determine if this item is being edited. Only provided for convenience. toggleIsEditing () => void  Toggles the isEditing flag. isExpanded: KnockoutObservable<boolean>  Flag to use to determine if this item is expanded. Only provided for convenience. toggleIsExpanded: () => void  Toggles the isExpanded flag. isVisible: KnockoutObservable<boolean>  Flag to use to determine if this item is shown. Only provided for convenience. toggleIsSelected () => void  Toggles the isSelected flag. selectSingle: (): boolean  Sets isSelected(true) on this object and clears on the rest of the items in the parent collection. isDirty: KnockoutObservable<boolean>  Dirty Flag. Set when a value on the model changes. Reset when the model is saved or reloaded. isLoaded: KnockoutObservable<boolean>  True once the data has been loaded. isLoading: KnockoutObservable<boolean>  True if the object is loading. isSaving: KnockoutObservable<boolean>  True if the object is currently saving. isThisOrChildSaving: KnockoutComputed<boolean>  Returns true if the current object, or any of its children, are saving. load: id: any, callback?: (self: T) => void): JQueryPromise<any> | undefined  Loads the object from the server based on the id specified. If no id is specified, the current id, is used if one is set. loadChildren: callback?: () => void) => void  Loads any child objects that have an ID set, but not the full object. This is useful when creating an object that has a parent object and the ID is set on the new child. loadFromDto: data: any, force?: boolean, allowCollectionDeletes?: boolean) => void  Loads this object from a data transfer object received from the server. force - Will override the check against isLoading that is done to prevent recursion.allowCollectionDeletes - Set true when entire collections are loaded. True is the default. In some cases only a partial collection is returned, set to false to only add/update collections. force - Will override the check against isLoading that is done to prevent recursion. allowCollectionDeletes - Set true when entire collections are loaded. True is the default. In some cases only a partial collection is returned, set to false to only add/update collections. deleteItem: callback?: (self: T) => void): JQueryPromise<any> | undefined  Deletes the object without any prompt for confirmation. deleteItemWithConfirmation: callback?: () => void, message?: string): JQueryPromise<any> | undefined  Deletes the object if a prompt for confirmation is answered affirmatively. errorMessage: KnockoutObservable<string>  Contains the error message from the last failed call to the server. onSave: callback: (self: T) => void): boolean  Register a callback to be called when a save is done. Returns true if the callback was registered, or false if the callback was already registered. saveToDto: () => any  Saves this object into a data transfer object to send to the server. save: callback?: (self: T) => void): JQueryPromise<any> | boolean | undefined  Saves the object to the server and then calls a callback. Returns false if there are validation errors. parent: any  Parent of this object, if this object was loaded as part of a hierarchy. parentCollection: KnockoutObservableArray<T>  Parent of this object, if this object was loaded as part of list of objects. editUrl: KnockoutComputed<string>  URL to a stock editor for this object. showEditor: callback?: any): JQueryPromise<any>  Displays an editor for the object in a modal dialog. validate: (): boolean  Triggers any validation messages to be shown, and returns a bool that indicates if there are any validation errors. validationIssues: any  ValidationIssues returned from the server when trying to persist data warnings: KnockoutValidationErrors  List of warnings found during validation. Saving is still allowed with warnings present. errors: KnockoutValidationErrors  List of errors found during validation. Any errors present will prevent saving. Model-Specific Members ​ ​ The following members are generated for each generated ViewModel class and are unique to each class. The examples below are based on a type named Person. Configuration ​ ​ static coalesceConfig: Coalesce.ViewModelConfiguration<Person>  A static configuration object for configuring all instances of the ViewModel's type is created. See ViewModel Configuration. ViewModel Configuration coalesceConfig: Coalesce.ViewModelConfiguration<Person>  An per-instance configuration object for configuring each specific ViewModel instance is created. See ViewModel Configuration. ViewModel Configuration DataSources ​ ​ 
public dataSources = ListViewModels.PersonDataSources;
public dataSource: DataSource<Person> = new this.dataSources.Default();  For each of the Data Sources for a model, a class will be added to a namespace named ListViewModels.<ClassName>DataSources. This namespace can always be accessed on both ViewModel and ListViewModel instances via the dataSources property, and class instances can be assigned to the dataSource property. Data Sources Data Properties ​ ​ 
public personId: KnockoutObservable<number | null> = ko.observable(null);
public fullName: KnockoutObservable<string | null> = ko.observable(null);
public gender: KnockoutObservable<number | null> = ko.observable(null);
public companyId: KnockoutObservable<number | null> = ko.observable(null);
public company: KnockoutObservable<ViewModels.Company | null> = ko.observable(null);
public addresses: KnockoutObservableArray<ViewModels.Address> = ko.observableArray([]);
public birthDate: KnockoutObservable<moment.Moment | null> = ko.observable(moment());  For each exposed property on the underlying EF POCO, a KnockoutObservable<T> property will exist on the TypeScript model. For navigation properties, these will be typed with the corresponding TypeScript ViewModel for the other end of the relationship. For collections (including collection navigation properties), these properties will be KnockoutObservableArray<T> objects. Enum Members ​ ​ For each enum property on your POCO, the following will be created: public genderText: KnockoutComputed<string | null>  A KnockoutComputed<string> property that will provide the text to display for that property. public genderValues: Coalesce.EnumValue[] = [ 
    { id: 1, value: 'Male' },
    { id: 2, value: 'Female' },
    { id: 3, value: 'Other' },
];  A static array of objects with properties id and value that represent all the values of the enum. 
export namespace Person {
    export enum GenderEnum {
        Male = 1,
        Female = 2,
        Other = 3,
    };
}  A TypeScript enum that mirrors the C# enum directly. This enum is in a sub-namespace of ViewModels named the same as the class name. Collection Navigation Property Helpers ​ ​ For each collection navigation property on the POCO, the following members will be created: public addToAddresses: (autoSave?: boolean) => ViewModels.Address;  A method that will add a new object to that collection property. If autoSave is specified, the auto-save behavior of the new object will be set to that value. Otherwise, the inherited default will be used (see ViewModel Configuration) ViewModel Configuration public addressesListUrl: KnockoutComputed<string>;  A KnockoutComputed<string> that evaluates to a relative url for the generated table view that contains only the items that belong to the collection navigation property. Reference Navigation Property Helpers ​ ​ public showCompanyEditor: (callback?: any) => void;  For each reference navigation property on the POCO a method will be created that will call showEditor on that current value of the navigation property, or on a new instance if the current value is null. public companyText: KnockoutComputed<string>;  For each reference navigation property, a KnockoutComputed<string> property will be created that will provide the text to display for that property. This will be the property on the class annotated with [ListText]. [ListText] Instance Method Members ​ ​ public readonly getBirthDate = new Person.GetBirthDate(this);
public static GetBirthDate = class GetBirthDate extends Coalesce.ClientMethod<Person, moment.Moment> { ... };  For each Instance Method on your POCO, a class and instance member will be created as described in Methods - Generated TypeScript. Instance Method Methods - Generated TypeScript Previous pageGetting Started with Knockout Next pageTypeScript ListViewModelsTypeScript ListViewModels ​ ​ In addition to TypeScript ViewModels for interacting with instances of your data classes in TypeScript, Coalesce will also generated a List ViewModel for loading searched, sorted, paginated data from the server. TypeScript ViewModels These ListViewModels, like the ViewModels, are dependent on Knockout and are designed to be used directly from Knockout bindings in your HTML. Base Members ​ ​ The following members are defined on BaseListViewModel<> and are available to the ListViewModels for all of your model types: modelKeyName: string  Name of the primary key of the model that this list represents. includes: string  String that is used to control loading and serialization on the server. See Includes String for more information. Includes String items: KnockoutObservableArray<TItem>  The collection of items that have been loaded from the server. addNewItem: (): TItem  Adds a new item to the items collection. deleteItem: (item: TItem): JQueryPromise<any>  Deletes an item and removes it from the items collection. queryString: string  An arbitrary URL query string to append to the API call when loading the list of items. search: KnockoutObservable<string>  Search criteria for the list. This can be easily bound to with a text box for easy search behavior. See [Search] for a detailed look at how searching works in Coalesce. [Search] isLoading: KnockoutObservable<boolean>  True if the list is loading. isLoaded: KnockoutObservable<boolean>  True once the list has been loaded. load: (callback?: any): JQueryPromise<any>  Load the list using current parameters for paging, searching, etc Result is placed into the items property. message: KnockoutObservable<string>  If a load failed, this is a message about why it failed. getCount: (callback?: any): JQueryPromise<any>  Gets the count of items without getting all the items. Result is placed into the count property. count: KnockoutObservable<number>  The result of getCount(), or the total on this page. totalCount: KnockoutObservable<number>  Total count of items, even ones that are not on the page. nextPage: (): void  Change to the next page. nextPageEnabled: KnockoutComputed<boolean>  True if there is another page after the current page. previousPage: (): void  Change to the previous page. previousPageEnabled: KnockoutComputed<boolean>  True if there is another page before the current page. page: KnockoutObservable<number>  Page number. This can be set to get a new page. pageCount: KnockoutObservable<number>  Total page count pageSize: KnockoutObservable<number>  Number of items on a page. orderBy: KnockoutObservable<string>  Name of a field by which this list will be loaded in ascending order. If set to "none", default sorting behavior, including behavior defined with use of [DefaultOrderBy] in C# POCOs, is suppressed. [DefaultOrderBy] orderByDescending: KnockoutObservable<string>  Name of a field by which this list will be loaded in descending order. orderByToggle: (field: string): void  Toggles sorting between ascending, descending, and no order on the specified field. Model-Specific Members ​ ​ Configuration ​ ​ static coalesceConfig: Coalesce.ListViewModelConfiguration<PersonList, ViewModels.Person>  A static configuration object for configuring all instances of the ListViewModel's type is created. See ViewModel Configuration. ViewModel Configuration coalesceConfig: Coalesce.ListViewModelConfiguration<PersonList, ViewModels.Person>  An per-instance configuration object for configuring each specific ListViewModel instance is created. See ViewModel Configuration. ViewModel Configuration Filter Object ​ ​ public filter: {
    personId?: string
    firstName?: string
    lastName?: string
    gender?: string
    companyId?: string
} = null;  For each exposed scalar property on the underlying EF POCO, filter will have a corresponding property. If the filter object is set, requests made to the server to retrieve data will be passed all the values in this object via the URL's query string. These parameters will filter the resulting data to only rows where the parameter values match the row's values. For example, if filter.companyId is set to a value, only people from that company will be returned. These parameters all allow for freeform string values, allowing the server to implement any kind of filtering logic desired. The Standard Data Source will perform the following depending on the property type: Standard Data Source Dates with a time component will be matched exactly.Dates with no time component will match any dates that fell on that day.Strings will match exactly unless an asterisk is found, in which case they will be matched with string.StartsWith.Enums will match by string or numeric value. Multiple comma-delimited values will create a filter that will match on any of the provided values.Numeric values will match exactly. Multiple comma-delimited values will create a filter that will match on any of the provided values. Dates with a time component will be matched exactly. Dates with no time component will match any dates that fell on that day. Strings will match exactly unless an asterisk is found, in which case they will be matched with string.StartsWith. Enums will match by string or numeric value. Multiple comma-delimited values will create a filter that will match on any of the provided values. Numeric values will match exactly. Multiple comma-delimited values will create a filter that will match on any of the provided values. Example usage: Static Method Members ​ ​ public readonly namesStartingWith = new Person.NamesStartingWith(this);
public static NamesStartingWith = class NamesStartingWith extends Coalesce.ClientMethod<PersonList, string[]> { ... };  For each exposed Static Method on your POCO, the members outlined in Methods - Generated TypeScript will be created. Static Method Methods - Generated TypeScript DataSources ​ ​ 
public dataSources = ListViewModels.PersonDataSources;
public dataSource: DataSource<Person> = new this.dataSources.Default();  For each of the Data Sources on the class, a corresponding class will be added to a namespace named ListViewModels.<ClassName>DataSources. This namespace can always be accessed on both ViewModel and ListViewModel instances via the dataSources property, and class instances can be assigned to the dataSource property. Data Sources Previous pageTypeScript ViewModels Next pageTypeScript External ViewModelsTypeScript External ViewModels ​ ​ For all External Types in your model, Coalesce will generate a TypeScript class that provides a bare-bones representation of that type's properties. External Types These ViewModels are dependent on Knockout, and are designed to be used directly from Knockout bindings in your HTML. All data properties on the generated model are Knockout observables. Knockout Base Members ​ ​ The TypeScript ViewModels for external types do not have a common base class, and do not have any of the behaviors or convenience properties that the regular TypeScript ViewModels for database-mapped classes have. TypeScript ViewModels Model-Specific Members ​ ​ Data Properties ​ ​ 
public personId: KnockoutObservable<number | null> = ko.observable(null);
public fullName: KnockoutObservable<string | null> = ko.observable(null);
public gender: KnockoutObservable<number | null> = ko.observable(null);
public companyId: KnockoutObservable<number | null> = ko.observable(null);
public company: KnockoutObservable<ViewModels.Company | null> = ko.observable(null);
public addresses: KnockoutObservableArray<ViewModels.Address> = ko.observableArray([]);
public birthDate: KnockoutObservable<moment.Moment | null> = ko.observable(moment());  For each exposed property on the underlying EF POCO, a KnockoutObservable<T> property will exist on the TypeScript model. For navigation properties, these will be typed with the corresponding TypeScript ViewModel for the other end of the relationship. For collections (including collection navigation properties), these properties will be KnockoutObservableArray<T> objects. Enum Members ​ ​ For each enum property on your POCO, the following will be created: public genderText: KnockoutComputed<string | null>  A KnockoutComputed<string> property that will provide the text to display for that property. Previous pageTypeScript ListViewModels Next pageTypeScript Method ObjectsTypeScript Method Objects ​ ​ For each Custom Method you define, a class will be created on the corresponding TypeScript ViewModel (instance methods) or ListViewModel (static methods) that contains the properties and functions for interaction with the method. This class is accessible through a static property named after the method. An instance of this class will also be created on each instance of its parent - this instance is in a property with the camel-cased name of the method. Custom Method Here's an example for a method called Rename that takes a single parameter 'string name' and returns a string. Base Members ​ ​ The following members are available on the method object for all client methods: public result: KnockoutObservable<string>  Observable that will contain the results of the method call after it is complete. public rawResult: KnockoutObservable<Coalesce.ApiResult>  Observable with the raw, deserialized JSON result of the method call. If the method call returns an object, this will contain the deserialized JSON object from the server before it has been loaded into ViewModels and its properties loaded into observables. public isLoading: KnockoutObservable<boolean>  Observable boolean which is true while the call to the server is pending. public message: KnockoutObservable<string>  If the method was not successful, this contains exception information. public wasSuccessful: KnockoutObservable<boolean>  Observable boolean that indicates whether the method call was successful or not. ListResult<T> Base Members ​ ​ For methods that return a ListResult<T>, the following additional members on the method object will be available: public page: KnockoutObservable<number>  Page number of the results. public pageSize: KnockoutObservable<number>  Page size of the results. public pageCount: KnockoutObservable<number>  Total number of possible result pages. public totalCount: KnockoutObservable<number>  Total number of results. Method-specific Members ​ ​ public static Rename = class Rename extends Coalesce.ClientMethod<Person, string> { ... }  Declaration of the method object class. This will be generated on the parent ViewModel or ListViewModel. ViewModel ListViewModel public readonly rename = new Person.Rename(this)  Default instance of the method for easy calling of the method without needing to manually instantiate the class. This will be generated on the parent ViewModel or ListViewModel. ViewModel ListViewModel public invoke: (name: string, callback: (result: string) => void = null, reload: boolean = true): JQueryPromise<any>  Function that takes all the method parameters and a callback. If reload is true, the ViewModel or ListViewModel that owns the method will be reloaded after the call is complete, and only after that happens will the callback be called. public static Args = class Args { public name: KnockoutObservable<string> = ko.observable(null); }  Class with one observable member per method argument for binding method arguments to user input. Only generated for methods with arguments. public args = new Rename.Args()  Default instance of the args class. Only generated for methods with arguments. public invokeWithArgs: (args = this.args, callback?: (result: string) => void, reload: boolean = true) => JQueryPromise<any>  Function for invoking the method using the args class. The default instance of the args class will be used if none is provided. Only generated for methods with arguments. public invokeWithPrompts: (callback: (result: string) => void = null, reload: boolean = true) => JQueryPromise<any>  Simple interface using browser prompt() input boxes to prompt the user for the required data for the method call. The call is then made with the data provided. Only generated for methods with arguments. public resultObjectUrl: KnockoutObservable<string | null>  Observable that will contain an Object URL representing the last successful invocation result. Only generated for methods that return a file. Object URL methods that return a file public url: KnockoutComputed<string>  The URL for the method. Can be useful for using as the src attribute of an image or video HTML element for file-downloading methods. Any arguments will be populated from this.args. Only generated for HTTP GET methods, as configured by [ControllerAction]. [ControllerAction] Previous pageTypeScript External ViewModels Next pageViewModel ConfigurationViewModel Configuration ​ ​ A crucial part of the generated TypeScript ViewModels that Coalesce creates for you is the hierarchical configuration system that allows coarse-grained or fine-grained control over their behaviors. Hierarchy ​ ​ The configuration system has four levels where configuration can be performed, structured as follows: Root Configuration ​ ​ Coalesce.GlobalConfiguration: ModelConfiguration<any>
Coalesce.GlobalConfiguration.app: AppConfiguration  The root configuration contains all configuration properties which apply to class category (TypeScript ViewModels, TypeScript ListViewModels, and Services). The app property contains global app configuration that exists independent of any models. Then, for each class kind, the following are available: TypeScript ViewModels TypeScript ListViewModels Services Root ViewModel/ListViewModel Configuration ​ ​ Coalesce.GlobalConfiguration.viewModel: ViewModelConfiguration<BaseViewModel>
Coalesce.GlobalConfiguration.listViewModel: ListViewModelConfiguration<BaseListViewModel<BaseViewModel>, BaseViewModel>
Coalesce.GlobalConfiguration.serviceClient: ServiceClientConfiguration<ServiceClient>  Additional root configuration objects exist, one for each class kind. These configuration objects govern behavior that applies to only objects of these types. Root configuration can be overridden using these objects, although the practicality of doing so is dubious. Class Configuration ​ ​ ViewModels.ClassName.coalesceConfig: ViewModelConfiguration<ViewModels.ClassName>
ListViewModels.ClassNameList.coalesceConfig: ListViewModelConfiguration<ListViewModels.ClassNameList, ViewModels.ClassName>
Services.ServiceNameClient.coalesceConfig: ServiceClientConfiguration<ServiceName>  Each class kind has a static property named coalesceConfig that controls behavior for all instances of that class. Instance Configuration ​ ​ instance.coalesceConfig: ViewModelConfiguration<ViewModels.ClassName>
listInstance.coalesceConfig: ListViewModelConfiguration<ListViewModels.ClassNameList, ViewModels.ClassName>
serviceInstance.coalesceConfig: ServiceClientConfiguration<ServiceName>  Each instance of these classes also has a coalesceConfig property that controls behaviors for that instance only. Evaluation ​ ​ All configuration properties are Knockout ComputedObservable<T> objects. These observables behave like any other observable - call them with no parameter to obtain the value, call with a parameter to set their value. Whenever a configuration property is read from, it first checks its own configuration object for the value of that property. If the explicit value for that configuration object is null, the parent's configuration will be checked for a value. This continues until either a value is found or the root configuration object is reached. When a configuration property is given a value, that value is established on that configuration object only. Any dependent configuration objects will not be modified, and if those dependent configuration objects already have a value for that property, their existing value will be used unless that value is later set to null. To obtain the raw value for a specific configuration property, call the raw() method on the observable: model.coalesceConfig.autoSaveEnabled.raw(). Available Properties & Defaults ​ ​ The following configuration properties are available. Their default values are also listed. Note that all configuration properties are observables, but for simplicity the documentation below lists the underlying type. Root Configuration ​ ​ These properties on Coalesce.GlobalConfiguration are available to both ViewModelConfiguration, ListViewModelConfiguration, and ServiceClientConfiguration. baseApiUrl: string = '/api'  The relative url where the API may be found. baseViewUrl: string = ''  The relative url where the admin views may be found. showFailureAlerts: boolean = true  Whether or not the callback specified for onFailure will be called or not. onFailure: (obj, message) => alert(message)  A callback to be called when a failure response is received from the server. onStartBusy: obj => Coalesce.Utilities.showBusy()  A callback to be called when an AJAX request begins. onFinishBusy: obj => Coalesce.Utilities.hideBusy()  A callback to be called when an AJAX request completes. App Configuration ​ ​ These properties on Coalesce.GlobalConfiguration.app are not hierarchical - they govern the entire Coalesce application: select2Theme: string | null = null  The theme parameter to select2's constructor when called by Coalesce's select2 Knockout Bindings. Knockout Bindings ViewModelConfiguration ​ ​ saveTimeoutMs: number = 500  Time to wait after a change is seen before auto-saving (if autoSaveEnabled is true). Acts as a debouncing timer for multiple simultaneous changes. saveIncludedFields: string[] | null = null  An array of property names that, if set, will determine which fields will be sent to the server when saving. Only those values that are actually sent to the server will be mapped to the underlying entity. This can improves the handling of concurrent changes being made by multiple users against different fields of the same entity. Specifically, if one page is designed to edit fields A and B, and another page is designed for editing fields C and D, you can configure this setting appropriately on each page to only save the corresponding fields. Due to design limitations, this cannot be determined dynamically like it can with Vue's $saveMode property Vue's $saveMode property WARNING Surgical saves require DTOs on the server that are capable of determining which of their properties have been set by the model binder, as surgical saves are sent from the client by entirely omitting properties from the x-www-form-urlencoded body that is sent to the server. The Generated C# DTOs implement the necessary logic for this; however, any Custom DTOs must have this logic manually written by you, the developer. Either implement the same pattern that can be seen in the Generated C# DTOs, or do not use surgical saves with Custom DTOs. Generated C# DTOs Custom DTOs Generated C# DTOs autoSaveEnabled: boolean = true  Determines whether changes to a model will be automatically saved after saveTimeoutMs milliseconds have elapsed. autoSaveCollectionsEnabled: boolean = true  Determines whether or not changes to many-to-many collection properties will automatically trigger a save call to the server or not. showBusyWhenSaving: boolean = false  Whether to invoke onStartBusy and onFinishBusy during saves. loadResponseFromSaves: boolean = true  Whether or not to reload the ViewModel with the state of the object received from the server after a call to .save(). validateOnLoadFromDto: boolean = true  Whether or not to validate the model after loading it from a DTO from the server. Disabling this can improve performance in some cases. setupValidationAutomatically: boolean = true  Whether or not validation on a ViewModel should be setup in its constructor, or if validation must be set up manually by calling viewModel.setupValidation(). Turning this off can improve performance in read-only scenarios. onLoadFromDto: null | ((object: T) => void) = null  An optional callback to be called when an object is loaded from a response from the server. Callback will be called after all properties on the ViewModel have been set from the server response. initialDataSource: null | DataSource<T> | (new () => DataSource<T>) = null  The dataSource (either an instance or a type) that will be used as the initial dataSource when a new object of this type is created. Not valid for global configuration; recommended to be used on class-level configuration. E.g. ViewModels.MyModel.coalesceConfig.initialDataSource(MyModel.dataSources.MyDataSource); ListViewModelConfiguration ​ ​ No special configuration is currently available for ListViewModels. ServiceClientConfiguration ​ ​ No special configuration is currently available for ServiceClients. Previous pageTypeScript Method Objects Next pageKnockout BindingsKnockout Bindings ​ ​ Coalesce provides a number of knockout bindings that make common model binding activities much easier. Editors Note: On this page, some bindings are split into their requisite HTML component with their data-bind component listed immediately after. Keep this in mind when reading. Input Bindings ​ ​ select2Ajax ​ ​ Creates a select2 dropdown using the specified url and fields that can be used to select an object from the endpoint specified. Additional complimentary bindings include: url: string  The Coalesce List API url to call to populate the contents of the dropdown. idField: string  The name of the field on each item in the results of the AJAX call which contains the ID of the option. The value of this field will be set on the observable specified for the main select2Ajax binding. textField: string  The name of the field on each item in the results of the AJAX call which contains the text to be displayed for each option. object?: KnockoutObservable<Coalesce.BaseViewModel | null>  An observable that holds the full object corresponding to the foreign key property being bound to. If the selected value changes, this will be set to null to avoid representation of incorrect data (unless setObject is used - see below). setObject: boolean = false  If true, the observable specified by the object binding will be set to the selected data when an option is chosen in the dropdown. Binding itemViewModel is required if this binding is set. Additionally, requests to the API to populate the dropdown will request the entire object, as opposed to only the two fields specified for idField and textField like is normally done when this binding is missing or set to false. To override this behavior and continue requesting only specific fields even when setObject is true, add fields=field1,field2,... to the query string of the url binding. itemViewModel?: (new (newItem: object) => Coalesce.BaseViewModel)  A reference to the class that represents the type of the object held in the object observable. This is used when constructing new objects from the results of the API call. Not used if setObject is false or unspecified. For example, setObject: true, itemViewModel: ViewModels.Person. pageSize: number = 25  The number of items to request in each call to the server. format: string = '{0}'  A string containing the substring {0}, which will be replaced with the text value of an option in the dropdown list when the option is displayed. selectionFormat: string = '{0}'  A string containing the substring {0}, which will be replaced with the text value of the selected option of the dropdown list. cache: boolean = true  If true, a cache-busting querystring parameter will be included in AJAX requests. selectOnClose: boolean = false  Directly maps to select2 option selectOnClose. allowClear: boolean = true  Whether or not to allow the current select to be set to null. Directly maps to select2 option allowClear. placeholder: string = 'select'  Placeholder when nothing is selected. Directly maps to select2 option placeholder. openOnFocus: boolean = false  If true, the dropdown will open when tabbed to. Browser support may be incomplete in some versions of IE. select2AjaxMultiple ​ ​ Creates a select2 multi-select input for choosing objects that participate as the foreign object in a many-to-many relationship with the current object. The primary select2AjaxMultiple binding takes the collection of items that make up the foreign side of the relationship. This is NOT the collection of the join objects (a.k.a. middle table objects) in the relationship. Additional complimentary bindings include: url: string  The Coalesce List API url to call to populate the contents of the dropdown. In order to only receive specific fields from the server, add fields=field1,field2,... to the query string of the url, ensuring that at least the idField and textField are included in that collection. idField: string  The name of the field on each item in the results of the AJAX call which contains the ID of the option. The value of this field will be set as the key of the foreign object in the many-to-many relationship. textField: string  The name of the field on each item in the results of the AJAX call which contains the text to be displayed for each option. itemViewModel: (new (newItem: object) => Coalesce.BaseViewModel)  A reference to the class that represents the types in the supplied collection. For example, a many-to-many between Person and Case objects where Case is the object being bound to and Person is the type represented by a child collection, the correct value is ViewModels.Person. This is used when constructing new objects representing the relationship when a new item is selected. pageSize: number = 25  The number of items to request in each call to the server. format: string = '{0}'  A string containing the substring {0}, which will be replaced with the text value of an option in the dropdown list when the option is displayed. selectionFormat: string = '{0}'  A string containing the substring {0}, which will be replaced with the text value of the selected option of the dropdown list. cache: boolean = true  If true, a cache-busting querystring parameter will be included in AJAX requests. selectOnClose: boolean = false  Directly maps to select2 option selectOnClose. allowClear: boolean = true  Whether or not to allow the current select to be set to null. Directly maps to select2 option allowClear. placeholder: string = 'select'  Placeholder when nothing is selected. Directly maps to select2 option placeholder. openOnFocus: boolean = false  If true, the dropdown will open when tabbed to. Browser support may be incomplete in some versions of IE. select2AjaxText ​ ​ Creates a select2 dropdown against the specified url where the url returns a collection of string values that are potential selection candidates. The dropdown also allows the user to input any value they choose - the API simply serves suggested values. url: string  The url to call to populate the contents of the dropdown. This should be an endpoint that returns one of the following: A raw string[]An object that conforms to { list: string[] }An object that conforms to { object: string[] }An object that conforms to { list: { [prop: string]: string } } where the value given to resultField is a valid property of the returned objects.An object that conforms to { object: { [prop: string]: string } } where the value given to resultField is a valid property of the returned objects. A raw string[] An object that conforms to { list: string[] } An object that conforms to { object: string[] } An object that conforms to { list: { [prop: string]: string } } where the value given to resultField is a valid property of the returned objects. An object that conforms to { object: { [prop: string]: string } } where the value given to resultField is a valid property of the returned objects. The url will also be passed a search parameter and a page parameter appended to the query string. The chosen endpoint is responsible for implementing this functionality. Page size is expected to be some fixed value. Implementer should anticipate that the requested page may be out of range. The cases listed above that accept arrays of objects (as opposed to arrays of strings) require that the resultField binding is also used. These are designed for obtaining string values from objects obtained from the standard list endpoint. resultField?: string  If provided, specifies a field on the objects returned from the API to pull the string values from. See examples in url above. allowCustom: boolean = true  If false, the user's search input will not be presented as a valid selectable value; only the exact values obtained from the API endpoint will be selectable. selectOnClose: boolean = false  Directly maps to select2 option selectOnClose. allowClear: boolean = true  Whether or not to allow the current select to be set to null. Directly maps to select2 option allowClear. placeholder: string = 'select'  Placeholder when nothing is selected. Directly maps to select2 option placeholder. openOnFocus: boolean = false  If true, the dropdown will open when tabbed to. Browser support may be incomplete in some versions of IE. select2 ​ ​ Sets up a basic select2 dropdown on an HTML select element. Dropdown contents should be populated through other means - either using stock Knockout bindings or server-side static contents (via cshtml). Knockout selectOnClose: boolean = false  Directly maps to select2 option selectOnClose. allowClear: boolean = true  Whether or not to allow the current select to be set to null. Directly maps to select2 option allowClear. placeholder: string = 'select'  Placeholder when nothing is selected. Directly maps to select2 option placeholder. openOnFocus: boolean = false  If true, the dropdown will open when tabbed to. Browser support may be incomplete in some versions of IE. datePicker ​ ​ Creates a date/time picker for changing a moment.Moment property. The control used is bootstrap-datetimepicker bootstrap-datetimepicker preserveDate: boolean = false  If true, the date portion of the moment.Moment object will be preserved by the date picker. Only the time portion will be changed by user input. preserveTime: boolean = false  If true, the time portion of the moment.Moment object will be preserved by the date picker. Only the date portion will be changed by user input. format: string = 'M/D/YY h:mm a'  Specify the moment-compatible format string to be used as the display format for the text value shown on the date picker. Defaults to M/D/YY h:mm a. Direct pass-through to bootstrap-datetimepicker. bootstrap-datetimepicker sideBySide: boolean = false  If true, places the time picker next to the date picker, visible at the same time. Direct pass-through to corresponding bootstrap-datetimepicker option. bootstrap-datetimepicker stepping: number = 1  Direct pass-through to corresponding bootstrap-datetimepicker option. bootstrap-datetimepicker timeZone: string = ''  Direct pass-through to corresponding bootstrap-datetimepicker option. bootstrap-datetimepicker keyBinds = { left: null, right: null, delete: null }  Override key bindings of the date picker. Direct pass-through to corresponding bootstrap-datetimepicker option. bootstrap-datetimepicker updateImmediate: boolean = false  If true, the datePicker will update the underlying observable on each input change. Otherwise, the observable will only be changed when the datePicker loses focus (on blur). saveImmediately ​ ​ When used in a context where $data is a Coalesce.BaseViewModel, that object's saveTimeoutMs configuration property (see ViewModel Configuration) will be set to 0 when the element it is placed on gains focus. This value will be reverted to its previous value when the element loses focus. This will cause any changes to the object, including any observable bound as input on the element, to trigger a save immediately rather than after a delay (defaults to 500ms). ViewModel Configuration delaySave ​ ​ When used in a context where $data is a Coalesce.BaseViewModel, that object's autoSaveEnabled configuration property (see ViewModel Configuration) will be set to false when the element it is placed on gains focus. This will cause any changes to the object, including any observable bound as input on the element, to not trigger auto saves while the element has focus. When the element loses focus, the autoSaveEnabled flag will be reverted to its previous value and an attempt will be made to save the object. ViewModel Configuration Display Bindings ​ ​ tooltip ​ ​ Wrapper around the Bootstrap tooltip component. Binding can either be simply a string (or observable string), or it can be an object that will be passed directly to the Bootstrap tooltip component. Bootstrap tooltip component fadeVisible ​ ​ Similar to the Knockout visible binding, but uses jQuery fadeIn/fadeOut calls to perform the transition. slideVisible ​ ​ Similar to the Knockout visible, but uses jQuery slideIn/slideOut calls to perform the transition. moment ​ ​ Controls the text of the element by calling the format method on a moment object. momentFromNow ​ ​ Controls the text of the element by calling the fromNow method on a moment object. If shorten is true, certain phrases will be slightly shortened. Utility Bindings ​ ​ let ​ ​ The let binding is a somewhat common construct used in Knockout applications, but isn't part of Knockout itself. It effectively allows the creation of variables in the binding context, allowing complex statements which may be used multiple times to be aliased for both clarity of code and better performance. Knockout Binding Defaults ​ ​ Knockout Helpers ​ ​ These are static properties on IntelliTect.Coalesce.Knockout.Helpers.Knockout you can assign to somewhere in the app lifecycle startup to change the default markup generated server-side when using @Knockout.* methods to render Knockout bindings in your .cshtml files. public static int DefaultLabelCols { get; set; } = 3;  The default number of Bootstrap grid columns a field label should span across. public static int DefaultInputCols { get; set; } = 9;  The default number of Bootstrap grid columns a form input should span across. public static string DefaultDateFormat { get; set; } = "M/D/YYYY";  Sets the default date-only format to be used by all date/time pickers. This only applies to models with a date-only [DateType] attribute. [DateType] public static string DefaultTimeFormat { get; set; } = "h:mm a";  Sets the default time-only format to be used by all date/time pickers. This only applies to models with a time-only [DateType] attribute. [DateType] public static string DefaultDateTimeFormat { get; set; } = "M/D/YYYY h:mm a";  Sets the default date/time format to be used by all date/time pickers. This only applies to DateTimeOffset model properties that do not have a limiting [DateType] attribute. [DateType] Note DefaultDateFormat, DefaultTimeFormat and DefaultDateTimeFormat all take various formatting strings from the Moment.js library. A full listing can be found on the Moment website. Moment website Timezone ​ ​ The date/time picker properties can be coupled with DateTimeOffset model properties to display time values localized for the current user's locale. If you want to make the localization static, simply include a script block in your _Layout.cshtml or in a specific view that sets the default for Moment.js: Note This needs to happen after Moment is loaded, but before the bootstrap-datetimepicker script is loaded. Previous pageViewModel Configuration